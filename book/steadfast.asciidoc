= Steadfast Self-Hosting: Rapid-Rise Personal Cloud
:author: Adam Monsen
:copyright: (C)2025 {author}
:doctype: book
:docinfo:
:toc: macro
:toclevels: 2
:imagesdir: img
:front-cover-image: image:cover.png[]
:icons: font
:xrefstyle: full
:hide-uri-scheme:
// see https://pygments.org/languages/ for available languages and their short names
:source-highlighter: pygments
:!chapter-signifier:
// prevent unnecessary blocking fetch of fonts
:!webfonts:
:pdf-themesdir: pdf-theme
ifdef::shb-screenPDF[]
:pdf-theme: screen.yml
endif::[]
ifdef::shb-printPDF[]
:!front-cover-image:
:pdf-theme: print.yml
:media: prepress
endif::[]
// necessary for keyboard macro (kbd)
:experimental:
:keywords: linux, web, servers, sysadmin, computers, tech, self-hosting, FOSS
:description: Quickly learn the hows and whys of reliable self-hosted web services.
:revnumber: {build_git_tag}
:revdate: {build_date_time}
:revremark: {build_locale_lang}
// see https://docs.asciidoctor.org/asciidoc/latest/blocks/add-title/#captioned-titles
:listing-caption: Listing

ifdef::backend-html5[]
// https://github.com/asciidoctor/asciidoctor/issues/857
++++
<style>
  .imageblock > .title {
    text-align: inherit;
  }
</style>
++++
endif::backend-html5[]

include::locale/attributes-de.adoc[]

[colophon%notitle%nonfacing]
== Kolophon

--
_{doctitle}_
--

--
{copyright}.
Manche Rechte vorbehalten.
Dieses Buch ist lizenziert unter einer https://creativecommons.org/licenses/by-sa/4.0/[Creative Commons Attribution-ShareAlike 4.0 International (CC BY-SA 4.0) License].

image::cc-by-sa.svg[align="center"]
--

--
Das wunderschöne Titelbild wurde von meiner Tochter mit Krita gestaltet.
Mehr von ihrer großartigen Kunst findest du im Laufe des Buches.
--

--
Technische Redaktion von https://www.wondra.codes[Lenny Wondra].
--

--
Deutsche Übersetzung von Fiona Burkart.
--

--
Erstmals veröffentlicht im Jahr 2024 von https://sunrisedata.io[Sunrise Data Press].
--

--
Seattle, Washington, USA.
--

ifdef::backend-epub3[]
--
EPUB ISBN: 979-8-9908615-0-3
--
endif::[]

ifdef::shb-screenPDF[]
--
PDF ISBN: 979-8-9908615-2-7
--
endif::[]

ifdef::shb-printPDF+printQuality-standard[]
--
Paperback ISBN: 979-8-9908615-1-0
--

--
Library of Congress Control Number: 2024911437
--
endif::[]

ifdef::shb-printPDF+printQuality-premium[]
--
Premium paperback ISBN: 979-8-9908615-3-4
--
endif::[]

// "big" is perhaps deprecated, see https://docs.asciidoctor.org/asciidoc/latest/text/text-span-built-in-roles/#built-in
//
// ...or maybe it is only deprecated for HTML? See https://docs.asciidoctor.org/pdf-converter/latest/roles/

--
[.text-center]
image:sunrisedata-logo.svg[alt=Sunrise Data logo,width=49,height=97,fit=line] [.big]#Sunrise Data Press#
--

toc::[]

== Vorwort

Bevor ich 2006 anfing, im Open-Source-Bereich zu arbeiten, war ich als Community-Organisator in Massachusetts tätig.
Ich kannte die Auswirkungen eines Mangels an Informationszugang oder das Fehlen des „richtigen“ Handbuchs sehr gut – beides hindert Menschen daran, mitzubestimmen, wie sie ihr Leben gestalten.
Als Community-Organisatorin brachte ich den Menschen bei, wie man Lobbyarbeit betreibt.
Unsere Organisation lud Menschen ein, gemeinsam mit Abgeordneten Gesetze zu entwerfen, die ihren Bedürfnissen gerecht wurden und ihr Leben verbesserten.
Wir zeigten ihnen, wie man Spenden sammelt, und wie sie sich selbst und ihre Nachbarschaft organisieren können.
Und dann verlagerte sich alles zunehmend ins Internet – und wichtige Diskussionen darüber, wie wir die Schwächsten schützen und die nächste Generation stärken können, begannen, über unsere Computer stattzufinden.

Man kann Fortschritt entweder beklagen oder ihn annehmen.
Ich entschied mich dafür, ihn anzunehmen. Ich wollte Menschen stärken und ihnen helfen, ein Gefühl von Kontrolle über ihre Computer- und Technologienutzung zu erlangen.
Ich begann, ganz unterschiedliche Menschen aus der Freie-Software-Bewegung kennenzulernen. Einige von ihnen interessierten sich sehr dafür, wie der Code funktioniert, und andere - wie Adam - waren vor allem daran interessiert, auf welche Weise frei zugänglicher Code Menschen helfen kann.

Adam und ich lernten uns 2009 bei ((LFNW)) (LinuxFest Northwest) kennen, einer kostenlosen Community-Konferenz in Bellingham, Washington.
Ein gemeinsamer Freund hatte mir empfohlen, bei einem Besuch in Washington anlässlich des LFNW auch einmal Seattle zu besuchen – was bedeutete, dass wir gemainsam von Seattle nach Bellingham fuhren.
Wir trafen uns alle in Seattle zum Mittagessen und machten uns dann gemeinsam auf die zweistündige Autofahrt nach Bellingham.
Auf diesen Fahrten begannen wir wirklich, über das Fehlen einer Freie-Software-Veranstaltung in Seattle zu sprechen.
Uns wurde klar, dass es in Seattle Leute brauchte, die ihre Unternehmen zur Sponsorenrolle bewegen konnten (wie Adam und Rob Smith), und jemanden, der sich um Referenten kümmern und die Veranstaltung in der Freie-Software-Community bekannt machen konnte – und so kam es, dass ich (als Bewohnerin von Massachusetts) Mitbegründerin einer jährlichen Veranstaltung in Seattle wurde.

[#image-seagl-crew]
.Die SeaGL crew. Von links nach rechts: Salt, Deb, Patch, (mit french fry), Adam, Rob. Nicht im Bild: Chris, Jesse, Bri, Lisa, and viele andere.
image::seagl-crew.jpg[align="center",scaledwidth=80%]

Die erste ((SeaGL)) fand 2013 am Seattle Central College statt und war ziemlich improvisiert.
Keine Keynotes, viele gemeinsam genutzte Mehrfachsteckdosen und ein paar Freund*innen, die hineingezogen worden waren, ohne genau zu wissen, worauf sie sich da eingelassen hatten.
Wir hatten bewusst einen Freitag gewählt, um eventuell Studierende anzusprechen, solange der Campus geöffnet war, und einen Samstag, um den zweiten Tag für diejenigen zugänglich zu machen, deren Arbeitsstellen eine Teilnahme unter der Woche nicht unterstützten.
Die Veranstaltung war – und ist bis heute – kostenlos und offen für alle.

Adam tauchte bei unserer ersten Veranstaltung mit einem kleinen Stapel „Print-on-Demand“-Hüten und -T-Shirts auf, versehen mit unserem brandneuen Logo (natürlich eine seagull (eng. Möwe).
Die Auswahl der Vorträge lief nach dem Motto: „Wenn du einen Vortrag halten willst, dann halt einen.“
Adam hielt großartige Einführungsvorträge zu Git und Hadoop, und ich sprach über politische Rahmenbedingungen und Community-Organizing.
Wir hatten es noch nicht schriftlich festgehalten, aber SeaGL war von Anfang an dazu bestimmt, eine Konferenz für Anfängerinnen und Expertinnen zu sein, für Programmierer*innen und Politikbegeisterte, und für Vorträge über das gesamte Ökosystem – seine Schwächen, sein Potenzial und die Chancen zur Zusammenarbeit mit anderen Initiativen, die Menschen stärken wollen.

Nach dieser chaotischen ersten Ausgabe wurde uns klar: SeaGL sollte für alle sein – aber ganz besonders für Menschen, die einen Einstieg in Open Quellesuchten, in einer vielfältigen, teuren und technologiegetriebenen Region wie Seattle.
Wir wollten, dass SeaGL eine großartige erste Tech-Konferenz für Teilnehmende wird und eine einladende Plattform für angehende Vortragende bietet.
Später weiteten wir dieses Ziel aus und bemühten uns gezielt darum, weniger bekannte Sprecher*innen zu finden und ihnen ihre erste Keynote-Möglichkeit zu bieten.
Das gesamte SeaGL-Team (einschließlich Adam, natürlich!) war und ist mit voller Leidenschaft dabei, Neulinge willkommen zu heißen und eine freundliche, sichere und neugierige Atmosphäre zu schaffen.

Adam und ich kennen uns schon seit vielen Jahren.
Ich habe seine Tochter kennengelernt, die die talentierte Illustratorin dieses Buches ist, und auch seine Frau, die klug ist und unermüdlich neugierig darauf, wie Technologie unser Leben beeinflusst.
Sogar einige der Hühner habe ich getroffen – sie sind tatsächlich blitzsauber, wenn auch leider nicht besonders schlau.
Zum Glück werden sie äußerst gut versorgt, sodass sie nicht allzu viel Grips brauchen.

Kurz gesagt: Adam ist sehr engagiert – sowohl für Freie Software als auch dafür, Menschen zu stärken.
Außerdem ist er unglaublich nett!
Wirklich einer der nettesten Menschen, die ich je getroffen habe.
Wenn dich die Vorstellung anspricht, etwas Herausforderndes mit einem geduldigen und einfühlsamen Mentor anzugehen, und du neugierig auf das Thema Self-Hosting bist, dann ist dieses Buch genau das Richtige für dich.

Self-Hosting ist schwierig.
Ich selbst habe still Mailinglisten verfolgt, die versprachen, es einfach zu machen. Ich habe Vorträge besucht, Videos geschaut und Artikel gelesen – aber wirklich einfach wurde es nie.
Manche dieser Ressourcen fingen gefühlt erst bei Kapitel 2 an, andere waren voller Kommentare, die einem das Gefühl gaben, dass jede einigermaßen intelligente Person die fehlenden Informationen schon irgendwie selbst finden müsste.
Zum Glück hat Adam alles aufgenommen, was echte Anfänger*innen brauchen, um loszulegen – und dabei trotzdem viele Wahlmöglichkeiten offengelassen.

Self-Hosting ist aber auch wichtig.
In der Technik – und in der Welt insgesamt – verändert sich vieles sehr schnell.
Was man kontrolliert und was nicht, ist ständig im Wandel.
Self-Hosting gibt dir die Möglichkeit, ein paar Dinge in deiner eigenen Hand zu behalten – deine persönlichen Daten, deine Medien und die Art, wie du mit deiner digitalen Umgebung interagierst.
Es ermöglicht dir, selbst zu entscheiden, was du brauchst, und selbst zu wählen, wie du diesen Bedarf decken willst – ohne um Erlaubnis zu fragen oder dich an ein Unternehmen zu binden, dem du als Individuum egal bist.

Du solltest dieses Buch lesen, es mit anderen teilen und vielleicht – wenn du soweit bist – etwas an die Self-Hosting-Community zurückgeben.

--
Willkommen in der Welt des Self-Hosting,
--

[.big]#Deb Nicholson#

--
Gründerin, Seattle GNU/Linux Conference +
Geschäftsführerin, Python Software Foundation
--

:sectnums:

== Einführung

(((Datensouveränität)))
Datensouveränität bedeutet, die volle Kontrolle über die eigenen Daten zu haben.
Sie verspricht Privatsphäre, Freiheit und Nachhaltigkeit.
Datensouveränität zu verwirklichen ist sowohl spannend als auch praktisch – und sie fördert ((prosoziales Verhalten)).
Self-Hosting (also das Betreiben eines eigenen Servers) ist ein hervorragender Weg zur Datensouveränität.

Dieses Buch wird dir helfen, Self-Hosting effizient zu erlernen und in der Praxis anzuwenden.
Du wirst Selbstvertrauen im Umgang mit den damit verbundenen Herausforderungen gewinnen und die Vorteile aus erster Hand erleben.
Die Fähigkeiten, die du dir aneignest, sind sowohl zu Hause, am Arbeitsplatz als auch in deiner Gemeinschaft anwendbar.

=== Willkommen

Ich freue mich sehr dass du hier bist!

Ich möchte dir dabei helfen, einen Server zum Laufen zu bringen.
Das Self-Hosting-Ökosystem ist überfüllt und oft verwirrend – deshalb habe ich eine Reihe schwieriger Entscheidungen bereits für dich getroffen, basierend auf sinnvollen und erprobten Voreinstellungen.
Ich werde dir dabei helfen, deinen eigenen Server bereitzustellen (einzurichten) und einige nützliche Webdienste darauf zu installieren.
Bring mit, was auch immer du an Sysadmin-Erfahrung hast, ein paar motivierte Nutzer*innen – und den Wunsch, dir echte Self-Hosting-Kompetenz anzueignen.

Das Internet ist oft ein unerbittlicher Kampf um Geld und Aufmerksamkeit.
Unser Verhalten wird endlos getrackt – wir sind das Produkt.
Der Smog der Überwachung erstickt unsere Freiheit und untergräbt das Vertrauen.
Wir werden:

* Uns nicht mit billigen ((Cloud))-Diensten zufriedengeben.
* Ablenkungen reduzieren.
* Unsere Aufmerksamkeit, Zeit und Freiheit wertschätzen.
* Die klare, frische Luft geringerer Überwachung atmen, indem wir selbst eine Alternative zum erschreckenden gesellschaftlichen Standard schaffen, Privatsphäre gegen Bequemlichkeit zu tauschen.
* Geld sparen, indem wir viele Dienste effizient auf eigener Hardware betreiben – mit kaum zusätzlichen Kosten.
* Gutes tun für unsere Freund*innen, Familien und sozialen Gruppen.
* Dinge tun, die mit öffentlichen Diensten nicht möglich sind, weil wir vollständigen Zugriff auf unsere Rohdaten haben.
* Uns anpassen und wachsen, wenn sich Software weiterentwickelt – und dabei unsere Daten und Metadaten mitnehmen.
* Teilen, was und wann es sinnvoll ist – mit den Menschen, denen wir vertrauen.

Dies ist das Buch, das ich mir gewünscht hätte, als ich versucht habe, meinen Kindern ein sicheres Online-Erlebnis zu ermöglichen.

Neue Self-Hosterinnen können dieses Buch als Einstieg nutzen.
Erfahrene Self-Hosterinnen können meine Entscheidungen mit ihren eigenen vergleichen.

==== Voraussetzungen

Um das Beste aus diesem Buch herauszuholen, solltest du über grundlegende Sysadmin-Erfahrung verfügen. Dazu gehört die Fähigkeit, deinen Router und dein LAN (lokales Netzwerk) zu konfigurieren, Linux auf einem Computer zu installieren (im Folgenden als dein Server bezeichnet), dich per SSH (Secure Shell) mit deinem Server zu verbinden, Textdateien zu bearbeiten und Befehle auf dem Server auszuführen sowie Dateien zwischen deinem Server und anderen Geräten zu übertragen.

Falls dir eines dieser Konzepte nicht vertraut ist, hilft dir ein kurzer Abstecher zu deiner bevorzugten Suchmaschine oder ein Besuch bei einer lokalen Nutzergruppe sicher weiter.

Ich empfehle das Hosting auf bloßes Metal (greifbarer, lokal betriebener Computer-Hardware), was einige Anforderungen an den physischen Standort deines Servers mit sich bringt.
Mehr zu den Details und Anforderungen von Bare-Metal-Hosting findest du im Abschnitt <<Hardware vorbereiten>>.

Zum Schluss noch einige bewährte Vorgehensweisen, die du beim Lesen im Hinterkopf behalten solltest:

Dokumentiere alles, was du tust – selbst wenn es nur für dein zukünftiges Ich ist.
Hole dir Unterstützung und bilde andere aus, indem du deine Dokumentation nutzt, um Wissen weiterzugeben.
Bleib fokussiert, mach Pausen, sei geduldig und achte auf deinen Körper.
Bitte um Hilfe und fordere aktiv Rückmeldungen ein.
Höre auf deine Nutzer*innen, sammle Daten und passe dich entsprechend an.

=== Unterstütze den Author

Ich habe dieses Buch aus nach jahrelanger Recherche mit eigenen Reseourcen  viel Unterstützung großartiger Menschen geschrieben.
Siehe <<Danksagungen>> (gegen Ende des Buches).

Bitte https://selfhostbook.com/buy/[kaufe ein Exemplar] für dich selbst oder für jemand anderen – besonders, wenn du möchtest, dass ich in Zukunft weitere Bücher schreibe.

=== Textversion

Dieses Buch wurde am *{build_date_time}* mit `LANG` auf Einstellung `*{build_locale_lang}*` von der Quelle `{docname}{docfilesuffix}` mit Stand `{build_git_commit}`, Zweig `{build_git_branch}`, Makierung `{build_git_tag}`, mit *{build_os_release}* generiert.

=== Urheberrecht und Lizenz

_{doctitle}_ ist {copyright}.
Manche Rechte vorbehalten.

==== Vervielfältigung dieses Buches

Dieses Buch steht unter der Creative Commons Attribution-ShareAlike 4.0 International (CC BY-SA 4.0) Lizenz.

image::cc-by-sa.svg[align="center"]

===== Sie dürfen

Teilen::
  das Material in jede Format oder Medium vervielfältigen und weiterverbreiten und zwar für beliebige Zwecke, sogar kommerziell.
Bearbeiten::
  das Material remixen, verändern und darauf aufbauen und zwar für beliebige Zwecke, sogar kommerziell.

_Der Lizenzgeber kann diese Freiheiten nicht widerrufen solange Sie sich an die Lizenzbedingungen halten._

//Share::

===== Unter folgenden Bedingungen...

Namensnennung::
  Sie müssen angemessene Urheber- und Rechteangaben machen, einen Link zur Lizenz beifügen und angeben, ob Änderungen vorgenommen wurden.
  Diese Angaben dürfen in jeder angemessenen Art und Weise gemacht werden, allerdings nicht so, dass der Eindruck entsteht, der Lizenzgeber unterstütze gerade Sie oder Ihre Nutzung besonders.
Weitergabe unter gleichen Bedingungen::
  Wenn Sie das Material remixen, verändern oder anderweitig direkt darauf aufbauen, dürfen Sie Ihre Beiträge nur unter derselben Lizenz wie das Original verbreiten.
Keine weiteren Einschränkungen::
  Sie dürfen keine zusätzlichen Klauseln oder technische Verfahren einsetzen, die anderen rechtlich irgendetwas untersagen, was die Lizenz erlaubt.

===== Hinweise

Sie müssen sich nicht an diese Lizenz halten hinsichtlich solcher Teile des Materials, die gemeinfrei sind, oder soweit Ihre Nutzungshandlungen durch Ausnahmen und Schranken des Urheberrechts gedeckt sind.

Es werden keine Garantien gegeben und auch keine Gewähr geleistet.
Die Lizenz verschafft Ihnen möglicherweise nicht alle Erlaubnisse, die Sie für die jeweilige Nutzung brauchen. Es können beispielsweise andere Rechte wie Persönlichkeits- und Datenschutzrechte zu beachten sein, die Ihre Nutzung des Materials entsprechend beschränken.


==== Kopiere auch den Code dieses Buches

Siehe <<Weitere Ressourcen>> für den Quellcode.
Der Quellcode umfasst zwei Originalwerke, die du kopieren, verändern und weitergeben darfst.
Zum einen das Buch selbst, inklusive des Codes zur Erstellung schön gesetzter Versionen.
Zum anderen ein Lernwerkzeug namens mario (siehe <<_mario>>).

Die Lizenz für sämtlichen originalen Quellcode im Zusammenhang mit diesem Buch ist die GNU AGPL (Affero General Public License), veröffentlicht von der Free Software Foundation, entweder in Version 3 der Lizenz oder (nach deiner Wahl) jeder späteren Version.
Eine Kopie der AGPL ist in `mario/COPYING` enthalten.


=== Haftungsausschluss

Ich übernehme keine Gewährleistung und keine Garantie.
Der Kauf oder das Lesen dieses Textes stellt keine Vereinbarung über Support dar.

Obwohl bei der Erstellung dieses Buches mit größter Sorgfalt vorgegangen wurde, übernehme ich keine Verantwortung für Fehler oder Auslassungen sowie keine Haftung für Schäden, die aus der Nutzung des Codes oder der Inhalte entstehen.

Ich bin nicht beruflich mit den im Buch genannten Produkten verbunden und werde von den genannten Unternehmen nicht bezahlt.
Deren Urheberrechte, Marken und geistiges Eigentum gehören ihnen selbst.

Alle geäußerten Meinungen sind meine eigenen.

Ich beziehe mich in diesem Buch direkt auf viele Produkte und Unternehmen und teile meine konkreten, mühsam gewonnenen Erkenntnisse über ihre jeweiligen Stärken und Schwächen.
Mein Ziel ist es, aufzuklären und zu informieren.

Ich werde Abkürzungen nehmen.
Ich beabsichtige nicht, jedes Thema vollständig und erschöpfend zu behandeln.
Ich möchte, dass du schnell zum Wesentlichen kommst – und dann selbst entscheidest, ob, wann und wo du tiefer einsteigen möchtest.

Wenn du Widersprüche zu diesen Aussagen findest, gib mir bitte Bescheid.

Ich bin ein Mensch und mache Fehler.
Ich mache es dir leicht, Kontakt mit mir aufzunehmen, fehlende oder fehlerhafte Informationen zu melden – und sie bei Interesse auch selbst zu verbessern.
Bitte tu das!
Siehe <<Weitere Ressourcen>> für Kontaktinformationen und Hinweise, wie du Verbesserungen teilen kannst.

=== Schreibstil

Textformattierung:

[cols="2,3",id=style]
.Typographical conventions
|===
|Styled example |Used for

|`zpool status -t` |Inline command, filename, username, password, or variable.
Longer snippets of console text use language-specific syntax highlighting.
|kbd:[Ctrl+c] |Key(s) pressed on the keyboard.
|https://example.com |Bare (un-named) link.
https scheme is assumed and omitted.
|https://example.com[Example domain] |Named link.
Full URL appears in print version.
|`\https://cloud.example.com` |Non-working example link.
Replace `.example.com` with your actual domain name.
|<<System Design>> |Cross-reference to another section or chapter.
|===

Hinweise:

NOTE: Hilfreiche oder ergänzende Informationen.

TIP: Hier ist ein praktischer Tip!

IMPORTANT: Etwas von besonderer Bedeutung.

CAUTION: Eine vorsorgliche Warnung.

WARNING: Eine konkrete Warnung vor möglichen Problemen.

Seitenleisten:

****
Eigenständige oder ergänzende Inhalte werden visuell abgesetzt in einer Seitenleiste wie dieser dargestellt.
Seitenleisten können mit oder ohne Titel erscheinen.
****

Codeausschnitte:

.Beispiel-Codeausschnitt (🚀 server)
[source#example-code-snippet,bash]
----
echo foo | sed s/foo/bar/
----

Titel von Codeausschnitten können angeben, wo der Code ausgeführt werden soll.
Wird kein Ort genannt, wird der oder die beabsichtigten Ausführungsumgebungen im Text erklärt.
In diesem Fall weist „🚀 server“ darauf hin, dass dieser Bash-Skript-Ausschnitt auf deinem Server ausgeführt werden soll.

== Hintergrund

Du denkst vielleicht: „Das ist aber ganz schön viel Hintergrundinformation!“
Und du hast recht.

Ich gehe hier absichtlich so ausführlich auf den Hintergrund ein, weil ich beim Halten von Vorträgen über Self-Hosting etwas Wichtiges festgestellt habe:
Menschen wissen, wie man lernt und unterscheidet – aber sie wünschen sich eine sinnvolle Motivation, sich wirklich auf das Lernen einzulassen.

Ich hoffe, dass du genau das hier findest.

=== Wer bin ich?

Ich bin Vater, Tech-Unternehmer und begeisterter Verfechter von FOSS (freier und quelloffener Software).
Ich liebe es, zu erziehen, zu sorgen, zu lachen, zu singen, zuzuhören, zu programmieren, zu bauen, zu gestalten, zu debuggen, zu entwerfen, zu führen, zu managen – und noch mehr zu debuggen, zu lehren und zu schreiben.

Ich bin gut darin, Systeme und Prozesse zu verwalten und abzusichern, während ich gleichzeitig Datenschutz, Compliance und Zuverlässigkeit sicherstelle.

Am meisten stolz bin ich auf meine Familie, auf den Ausbau von https://mifos.org[Mifos], die Mitbegründung von https://seagl.org[SeaGL], den Verkauf von https://csats.com[C-SATS], und Buch geschrieben zu haben.

Ich betreibe seit Jahrzehnten meine eigenen Dienste.
Angefangen hat es mit einem Blog und einem Fotoalbum, die auf dem Rechner eines Freundes liefen.
Das Gefühl von Freiheit und Kontrolle war elektrisierend – und es unterstützte gleichzeitig meine Effektivität bei der Arbeit.
Deshalb habe ich weitergemacht und viele meiner Dienste selbst betrieben – wenn auch selten auf eigener Hardware.

Als ich eine Familie hatte, wuchsen unsere Anforderungen an Datenspeicherung und Funktionalität.
Ein einfaches Netzlaufwerk und Datei-Synchronisation reichten nicht mehr aus.
Zu Beginn der Pandemie saßen wir alle zuhause fest – und online.
Ich wurde skeptisch gegenüber Unternehmen, die aus dieser neuen Abhängigkeit Kapital schlagen wollten.
Also begann ich, mehr zu Hause selbst zu hosten – und stellte fest, wie überraschend einfach, nützlich und unterhaltsam das sein kann.

Etwa zur gleichen Zeit entschloss ich mich, mich von Google zu lösen (De-Googling).
Der Familienbedarf und mein Wunsch, Google zu meiden, passten hervorragend zusammen.
Self-Hosting war ein glücklicher Zufallstreffer.
Allein der Versuch, Google hinter sich zu lassen, war eine faszinierende und erfüllende Reise – begleitet von zahlreichen Self-Hosting-Experimenten.

=== Warum habe ich dieses Buch geschrieben?

Ich habe dieses Buch geschrieben, um ((Datensouveränität)) als prosoziales Verhalten zu fördern.
Dank Self-Hosting ist das heute einfacher denn je – und ich wollte dieses Wissen in Buchform weitergeben.

Die bisherigen Bücher zu diesem Thema bieten keine gute, schnelle und günstige Methode, um Self-Hosting auf eigener Hardware ((bloßes Metal)) umzusetzen.
Ich habe eine solche Methode gefunden – und ich glaube, du wirst sie lieben.
Sie funktioniert übrigens auch in der Cloud, kostet dort aber deutlich mehr (siehe <<Server>>).

Außerdem: Lernen macht Spaß.
Ich lerne beim Schreiben.
Als ich erforschte, wie mein Handy eigentlich funktioniert, wurde mir bewusst, wie wichtig es ist, zu verstehen, wie „die Cloud“ funktioniert – denn moderne Smartphones basieren stark auf Cloud-Diensten und -Daten.
Beim Versuch, mein Handy wirklich „mein eigenes“ zu machen (also so, dass es mir hilft, mein bestes Leben zu leben), kam mir die Idee, meine Daten in meiner eigenen Cloud zu hosten.

Fast alle Techies, die ich kenne, hosten irgendetwas selbst – oft etwas, das ich noch nie gehört habe.
Es gibt immer einen neuen Self-Hosting-Dienst zum Ausprobieren, Lernen, Optimieren und Weiterempfehlen.

Ich wollte außerdem das Buch schreiben, das ich mir gewünscht hätte, als ich mit Self-Hosting anfing.

Und: Es sollte einfach ein Buch darüber geben.
Online findest du unzählige Videos, Artikel und Code-Schnipsel, die alles in diesem Buch und mehr abdecken.
Viele davon sind großartig.
Aber dieses Buch gehört dir – zum Nachschlagen, Ausprobieren und Lernen.

Und: Es gibt eine auffällige Lücke zwischen einem nützlichen Einzelrechner und nützlichen ((Cloud-Diensten)).
Cloud ist leicht zu bezahlen – aber die wahren Kosten sind verborgen: Überwachung, Abhängigkeit, Inflexibilität.

Ich kann mir gut vorstellen, dass wir in Zukunft Datengeräte für den privaten Haushalt besitzen werden, die Privatsphäre wirklich respektieren – so selbstverständlich wie heute ein Kühlschrank.
Solche Geräte wurden schon oft versucht und es wird immer wieder neue Versuche geben.
Bis sich ein solches Gerät durchsetzt, bleibt Self-Hosting – also das Einrichten eines eigenen Servers und eigener Dienste – eine hervorragende Lösung.


=== Warum dieser Titel?

==== Steadfast Self-Hosting

Ich mag das Wort _steadfast_ (_standhaft_).
Es erinnert mich an verlässliche Dinge und Menschen.

(((Datensouveränität)))
Der Schlüssel zu zuverlässigem Self-Hosting ist Datensouveränität.
Software wird sich ändern, Dienste werden sich ändern, du wirst dich ändern, und die Welt wird sich ändern.
Wenn deine Daten dir durch all diese Veränderungen zuverlässig dienen sollen, musst du die Kontrolle über sie haben.

Es macht tatsächlich einen Unterschied, eine eigene Kopie zu besitzen.
Du könntest den Zugriff auf etwas verlieren, das du vermeintlich „gekauft“ hast – weil du es in Wahrheit nur gemietet hast.
Es könnte sich sogar direkt vor deinen Augen verändern.
Mehr dazu:

* https://kotaku.com/sony-ps4-ps5-discovery-mythbusters-tv-1851066164[PlayStation To Delete A Ton Of TV Shows Users Already Paid For] by Ethan Gach
* https://defectivebydesign.org/what_is_drm[What is DRM?] by the Free Software Foundation
* https://nytimes.com/2023/04/04/arts/dahl-christie-stine-kindle-edited.html[It's Their Content, You're Just Licensing it] by Reggie Ugwu

(((Quelleof truth)))
Das Speichern von Kopien von Daten, die jemand anderes für dich hostet, ist in Ordnung.
Self-Hosting geht einen Schritt weiter und verschafft dir weitreichende Kontrolle darüber, wie deine Daten verwendet und geteilt werden.
Du erhältst die Kontrolle über autoritative Kopien deiner Dateien – du weißt also, was die "Wahrheit" ist und kannst sie bestimmen.
Und das alles mit Zuverlässigkeit und Flexibilität zu einem vertretbaren Budget.

Self-Hosting bedeutet, Computerdienste von und für Einzelpersonen, Familien und Hobby-Anwender in SOHO-Umgebungen (Small Office / Home Office) bereitzustellen.

Vielleicht ist „Hosting für kleine Gemeinschaften“ sogar der treffendere Begriff.
Du liest auf jeden Fall das richtige Buch, wenn du Dienste für eine kleine Gemeinschaft bereitstellen möchtest.

Zum Schluss noch ein Hinweis zur Terminologie:
In der Informatik – insbesondere bei Compilern – bezeichnet „Self-Hosting“ einen besonders schönen Meilenstein: nämlich wenn eine Programmiersprache sich selbst kompilieren kann.
An meine Freunde in den angrenzenden Disziplinen:
Es tut mir leid, dass ich den Begriff „Self-Hosting“ hier so frei überlade, um „Hosting für kleine Gemeinschaften“ zu meinen.
Ihr hattet ihn zuerst – ich leihe ihn mir nur aus und hoffe, dass unsere kontextuellen Fahrbahnmarkierungen Zusammenstöße verhindern.

==== Rapid-Rise Personal Cloud

_Rapid_ ist dazu da, dich zu motivieren, sofort einzusteigen und zu lernen
_Rapid_ bedeutet nicht gleich _rücksichtslos_!
Ich setze mich entschieden für einen durchdachten und robusten Ansatz beim Self-Hosting ein.
Wenn du auf eine Herausforderung stößt, nimm dir Zeit – so lernst du am Ende schneller.
Sobald du ein Konzept verstanden hast, übe es.
Scheitere früh und oft – mit schnellen Iterationen auf dem Weg zur Perfektion.

_Rapid-rise_ steht oft auf einer Packung Backhefe – und ich liebe frisch gebackenes Brot.
Wenn dein Server also ein Laib Brot ist, dann ist dieses Buch deine Schnellhefe.

[#image-bread-server]
.Server in der Form eines Brots.
image::bread-server.png[align="center",scaledwidth=80%]

_Cloud_ bedeutet, dass es skalierbar und automatisierbar ist.
_Personal_ begrenzt diese Skalierbarkeit auf ein sinnvolles Maß für eine kleine Gruppe.“
Ein ((bloßes Metal)) Server kann innerhalb seiner eigenen Hardware bis zu einem gewissen Maß skalieren
Es kann sich automatisch anpassen, indem es je nach ((Rechen-))Bedarf mehr oder weniger Leistung nutzt, und manuell, wenn man Hardware-Komponenten aufrüstet (zum Beispiel durch Hinzufügen einer weiteren Festplatte).”

Ich gebe zu, mein inneres Kind freut sich über die Mehrdeutigkeiten des Begriffs _Personal Cloud_.

=== Für wen ist dieses Buch??

Dieses Buch ist für Menschen, die freundlich zu anderen sind, mutig darin, Neues auszuprobieren, neugierig auf die Möglichkeiten des Self-Hostings und entweder unsicher, wie sie es angehen sollen, oder eifrig, ihr bestehendes Homelab (Self-Hosting-Setup) zu verbessern.

Dieses Buch ist für Menschen, die wissen wollen, wo ihre Daten leben, und in der Lage sein möchten, allerlei Magie damit zu vollbringen.
Es ist ein „von Grund auf“ oder „der harte Weg“-Ansatz und hält die Türen weit offen für viele Möglichkeiten mit einer prinzipientreuen Self-Hosting-Technik.
Manchmal berichte ich, was für mich funktioniert hat, anstatt konkret zu empfehlen, was du tun solltest.

Dieses Buch ist für Menschen, die neugierig auf FOSS sind oder diesem bereits zugeneigt sind.
Und – so viel ich auch über FOSS reden werde – ich bin hier nicht, um zu urteilen.
Ich bin hier, um zu wachsen, vor allem durch Teilen und Lernen.

Dieses Buch ist für Studierende, insbesondere technikaffine oder techniknahe Studierende, die in Clubs und Teams aktiv sind.

Dieses Buch bietet Motivation für Self-Hosting und einen exzellenten Lernprozess dafür.
Seine versionsspezifischen Inhalte werden voraussichtlich mit der Zeit veralten.
Seine Motivation und sein Lernprozess werden mit der Zeit immer relevanter.

Dieses Buch ist für diejenigen, die versuchen, mehr für andere und weniger für sich selbst zu leben; die selbstlos sind und dabei das „selbstlos sein“ genießen.
Führungskräfte, Eltern/Erziehungsberechtigte, Mitglieder einer Gemeinschaft oder einer kleinen Gruppe von Freunden.
Menschen, die Self-Hosting betreiben wollen, die auch andere lieben und neben der Systemadministration noch andere Dinge tun möchten.
Ich werde dir wertvolle Zeit für diese anderen Dinge sparen, während ich die Sysadmin-Anteile unterhaltsam gestalte.

Ähnlich wie bei „small community hosting“ wären _Small Group Cloud_ passendere Bezeichnungen als _Personal Cloud_.
_Small group_ (Kleingruppe) ist eine großartige Zielgröße für das, was du erschaffen wirst.
Ich würde mir die Mühe nicht machen, das alles nur für mich selbst zu tun.

Dieses Buch richtet sich an Menschen, die sich für Self-Hosting interessieren oder daran interessiert sind, damit zu beginnen.
Es ist darauf ausgelegt, die nützliche, sichere und schnelle Einrichtung eines einzelnen Bare-Metal-Servers mit vielen Diensten zu unterstützen.

Dieses Buch ist für Menschen, die _de-Google_, _de-iTunes_, _de-OneDrive_, _de-Dropbox_, _de-Wasauchimmer_ machen möchten.

=== Was ist dieses Buch _nicht_?

Dies ist kein umfassender Leitfaden zum Thema Self-Hosting.
Ich werde nicht versuchen, die endlosen Möglichkeiten aufzulisten, wie man Hardware, Betriebssysteme, Isolierungstechniken und Dienste kombinieren kann.
Dieses Buch richtet sich an den kleinen Maßstab.
Suchen Sie anderswo nach:

* Hochverfügbarkeit
* Enterprise-Sicherheit
* N+1-Redundanz
* Verwaltung vieler Rechner
* Clustering
* Single Sign-On
* Erweiterte Überwachung und Zentralisierung von Metriken
* Einhaltung gesetzlicher Vorschriften
* Erkennung und Abwehr von Eindringlingen/Bedrohungen
* Tiefgehende Sicherheitshärtung
* Betrieb eines eigenen Container-Registrierung
* 100 % Offline- / autarkes Self-Hosting

TEs gibt einige Themen wie diese, die ich überspringen oder nur kurz behandeln werde.
Jedes einzelne dieser Themen ist eine ganze Branche, ein weiteres Stück Hardware, eine Einstellung an deinem Heimrouter, eine potenzielle Karriere, keines oder alles davon – und auf jeden Fall eine Überlegung wert.
Du kannst und solltest dir ihrer bewusst sein.
Falls du das Gefühl hast, dass ich etwas, das für meine Methode des Self-Hostings kritisch relevant ist, komplett ausgelassen habe, lass es mich bitte wissen.

Dieses Buch richtet sich nicht an diejenigen, die bereits mit umfangreichen Ressourcen alles umgesetzt haben.
Wenn du 50.000 Dollar und unbegrenzt Zeit hast, um deinen Betonbunker-Homelab einzurichten … nun, darf ich eine Führung haben?
Ich würde das wirklich gern sehen.
Wenn du eher neugierig als sicher bist, kannst du trotzdem Spaß daran haben, aus meinen Entscheidungen zu lernen.

Ich schreibe nicht, um es hartgesottenen Software-Patent- und Lizenz-Aktivisten recht zu machen.
Diese großartigen Menschen werden meine absichtliche Verwendung des Wortes _open_ (_offen_) und das Weglassen des Wortes _libre_ (_frei_) sofort bemerken.
Ich liebe all diese Begriffe, ich stimme zu, dass Worte wichtig sind, und ich stehe auf der Seite der Inklusion – auch wenn das Idealismus kosten kann (wobei ich hoffe, dass diese Konzepte sich nicht ausschließen).
Ich danke den Aktivisten dafür, dass sie geholfen haben, die Nadel in Richtung Freiheit zu bewegen – zu unserem aller Nutzen.

Dieses Buch ist kein Manifest für immer und ausschließlich Self-Hosting.
Es ist vollkommen in Ordnung, einige Dienste selbst zu hosten und für andere zu bezahlen.
Du wirst deine eigene Checkliste entwickeln, was du wann selbst hosten möchtest.
Meine fokussiert darauf, mir und meiner Familie eine nützliche, verlässliche und zukunftssichere Cloud bereitzustellen.

Dieses Buch ist nicht der schnellste Weg, um Webdienste auszuprobieren.
Für viele Projekte findest du meist Demo-Instanzen im Netz.
Es gibt Cloud-Anbieter, die einen Dienst für dich betreiben und deine Daten hosten.

Siehe auch: <<Alternativen zu mario>>.

=== Wie Buch schreiben?

Wieso sprichst du wie ein Höhlenmensch?

(((Vim)))
Ich habe das Buch ursprünglich in Markdown-Klartext in meinem zuverlässigen Texteditor geschrieben, https://www.vim.org[Vim].
(((Pandoc)))
Ich habe großzügige Mengen an https://pandoc.org[Pandoc], Zeit, and Liebe angewandt.
Pandoc ist ein fantastisches FOSS-Tool, das es mir ermöglichte, diese einzelne Klartextdatei mit gut lesbarem Markdown Satzbau zu verwenden, um mehrere unterschiedliche, ansprechende Outputs zu erzeugen.
Beim Überarbeiten bin ich auf das Build-System von https://github.com/progit/progit2[Pro Git 2] gestoßen. (Danke an Scott und Ben!).
Kurz gesagt habe ich das Buch auf https://asciidoc.org[AsciiDoc] umgestellt und meinen Satzcode auf https://asciidoctor.org[Asciidoctor] portiert.
Das vereinfachte den Bucherstellungsprozess und ermöglichte mir mehr und bessere Output-Formate.

TIP: Schau dir den Quellcode an – du bist herzlich eingeladen, ihn zu bearbeiten und anzupassen.
Siehe <<Weitere Ressourcen>>.

Ich habe versucht, so viel wie möglich auf Standard-FOSS-Software zurückzugreifen und nur minimal anzupassen.
Das hat mir geholfen, mich auf den Inhalt zu konzentrieren und das Buch einfach genug zu halten, um es selbst zu veröffentlichen.

==== Wann Buch schreiben?

Immer noch mit dem Höhlenmenschen.
Reicht jetzt aber.
Ich habe dieses Buch 2023 geschrieben.
Und hör zu, selbst wir gesegneten Höhlenbewohner sollten dem Selbst-Hosting eine Chance geben.
Wir schaffen das!

==== Wo?

Seattle.

==== Hey.

Zugegeben, die letzten paar Abschnitte existieren nur, damit ich alle https://de.wikipedia.org/wiki/Fragetechnik#Offene_W-Fragen_in_der_Praxis[5 Ws] (wer, was, wann, wo, warum) abdecken und das ‚Höhlenmenschen‘-Gimmick einbauen kann.

=== Eine Anmerkung zu FOSS

(((FOSS, author's bias towards)))

Ich bevorzuge FOSS gegenüber nicht-FOSS.
Das kann ein polarisierendes Thema sein.
Allein schon der Gebrauch des Begriffs FOSS statt anderer Varianten kann kontrovers sein.
Aber das alles sind nur Ablenkungen.
Gerade heute brauchen wir Kompromissbereitschaft, Geduld und Freundlichkeit.
Neugier statt Gewissheit.

Hier ist mein Versprechen an dich, lieber Leserin:

Ich werde versuchen, nicht zu sehr zu predigen.

Ich werde _praktische_ Lösungen _idealistischen_ vorziehen.
Manchmal werde ich das nicht schaffen – besonders wenn es um FOSS geht.
Am deutlichsten zeigt sich das darin, dass ich in diesem Buch nicht-FOSS-Alternativen kaum erwähne.

Ich kenne die Spannung zwischen praktischen und idealistischen Lösungen, und ich glaube, dass diese Spannung etwas Gutes ist – weil sie uns dazu bringt, kritisch zu überlegen, welche ((Cloud))-Dienste wir nutzen sollten, und nicht nur, welche wir nutzen können.
Das ist eine kurze Überlegung wert.

Unsere Daten sind wichtig, und unsere persönlichen Entscheidungen ebenso.
Ihre Auswirkungen betreffen auch die Gruppen, zu denen wir gehören – ebenso wie die Chance auf Verbesserung.

Ich glaube, dass selbstgehostetes ((FOSS)) machbar ist und viele praktische Vorteile gegenüber nicht-FOSS bietet.

Halte durch und gib mir Rückmeldung.
Du wirst deinen eigenen Mittelweg zwischen Idealismus und Pragmatismus finden, und ich bin gespannt, wo du am Ende landest.

== Deine Reise

Die stetigen Fortschritte in Hard- und Software machen Self-Hosting heute einfacher und günstiger denn je.
Und in einem entscheidenden Punkt deutlich komplexer: Für Einsteiger gibt es eine überwältigende Anzahl an Entscheidungen zu treffen.

Halte durch.
Ich helfe dir, die Auswahl einzugrenzen, indem ich dir gezielte und praxisnahe Empfehlungen gebe.

Mach dir nicht zu viele Sorgen über einzelne Entscheidungen.
Deine persönliche Cloud ist formbar.
Tausche nach Belieben Komponenten aus.
Wenn du dich mal falsch entscheidest, triff einfach eine neue Entscheidung – idealerweise basierend auf Metriken und tatsächlichen Nutzerbedürfnissen.

Du bist keine Versagerin, wenn du nicht gleich beim ersten Mal alles richtig machst.

Es ist völlig in Ordnung, langsam von dem umzusteigen, was du derzeit nutzt.
Du musst nicht alles auf einmal umkrempeln.

Es ist auch völlig in Ordnung, gar nicht umzusteigen und dieses Buch nur zur persönlichen Weiterbildung und zum Experimentieren zu nutzen.

Und es ist okay, wenn du nicht perfekt nach deinen oder den Idealen anderer lebst.
Halte an deinen Werten fest, während du sie gleichzeitig hinterfragst und weiterentwickelst.
Genieße deine Reise.

=== Warum du deine Software selbst hosten solltest

Frag dich ruhig noch einmal – wie man es tun sollte – warum zur Hölle sollte überhaupt jemand Software-Dienste selbst hosten?
Es gibt so viele gute Gründe!

* Flexibilität
** nur die Dienste ausführen, die du und deine Nutzer*innen wollen
** mehrere Dienste nutzen, die denselben Datenspeicher verwenden
** automatisiere, was du willst, wann du willst
** unbegrenztes Teilen
** unbegrenztes Streaming
** unbegrenzte Auswahlmöglichkeiten
* Spaß!
** lernen und wachsen
** Self-Hosting ist eine machbare Herausforderung
** passende Rätsel lösen, während du lernst und dich verbesserst
** Teil der florierenden Self-Hosting-Community sein
* Zukunftssicher sein
** deine Nutzer*innen von den unvorhersehbaren Änderungen proprietärer Produktpreise, Serviceangebote und UI/UX abschirmen
** deine hart erarbeiteten Daten mit Freunden und Familie teilen – für immer
** problemlos auf etwas anderes migrieren, wenn nötig (zum Beispiel, wenn ein neuer/besserer Fotoserver verfügbar wird)
** es sind wirklich die Daten, die geschützt werden müssen; die Frontends zu diesen Daten (Dateiviewer, Editoren etc.) werden sich ändern, wenn du es entscheidest
* Computing demokratisieren
** selbstgehostete Software (insbesondere FOSS) ermöglicht Daten- und Rechenautonomie
* Strom sparen
** der Energieverbrauch im Cloud-Backend pro Gerät sinkt drastisch bei wenigen Nutzern
** je mehr Nutzer, desto mehr Stromersparnis
** siehe verlinkte Artikel in <<Server>>
* Geld sparen
** selbstgehostete Hardware ist in der Regel günstiger als die Cloud (also gemietete Dienste)
** Einsparungen steigen, wenn der Speicherbedarf deiner Nutzer*innen in den Terabyte-Bereich geht
** spare mehr mit jedem weiteren Dienst, den du betreibst
** unerwartete Kosten bei Public-Cloud-Anbietern vermeiden
*** Egress-Gebühren machen es teuer, deine Daten herunterzuladen und umzuziehen
*** vergisst man, eine VM (virtuelle Maschine) zu stoppen, kann es schnell teuer werden
*** du könntest übermäßig viel Zeit und Geld damit verbringen, dich durch das verwirrende Service-Menü der Public Cloud zu kämpfen
** unerwartete Änderungen bei Public-Cloud-Anbietern vermeiden
*** Änderungen bei Lizenzgebühren
*** Änderungen bei Nutzungsgebühren
*** Änderungen bei Supportkosten
*** Änderungen im Serviceangebot
** nahezu keine zusätzlichen Kosten für weitere Nutzer und Dienste
* Geschwindigkeit / Zeit sparen
** ein lokaler Server kann deutlich bessere Reaktionszeiten haben, vorausgesetzt, die Hardware ist angemessen und die Dienste gut konfiguriert
** lokale Daten ("data locality") bedeuten, dass du keine Rundreisen zu Rechenzentren anderer machen musst, um zu experimentieren
** gemeinsamer Speicher erlaubt es dir, deine Daten über mehrere Dienste bereitzustellen, mit sinnvoll definiertem Lese-/Schreibzugriff
* Vendor Lock-in vermeiden
** du kannst Softwarefunktionen nutzen, die Public-Cloud-Anbieter nicht anbieten oder die es dort noch nicht gibt, da du vollständigen Zugriff auf deine Rohdaten hast
** wenn du etwas mit DRM kaufst, besitzt du es nicht wirklich
** gibt es eine Integration, auf die du dich verlässt? Manchmal funktioniert ein Dienst nicht mehr mit einem anderen. Das passiert bei FOSS seltener, weil jeder ein Projekt einfach forken (kopieren, ändern und teilen) kann.
* Privatsphäre
** den abschreckenden Effekt der Massenüberwachung vermeiden
** mit einer persönlichen Cloud kannst du GPS-Breitengrad und -Längengrad sicher in deinen Fotometadaten behalten
** sobald du deine Standortdaten speicherst, kannst du kreative Dinge damit tun
** wenn du deine Position und dein Verhalten nicht ständig mit Google teilen musst, warum tust du es?
** entferne dich aus der Gleichung der Nutzeranalyse – wenn du ein Video über einen fremden Dienst streamst, wissen sie und analysieren jedes Mal, wenn du (oder deine Kinder) ein Video, das du "besitzt", (erneut) ansiehst, zurückspulst, vorspulst, pausierst... aber müssen sie das wissen? warum?
* Neue Möglichkeiten erschließen
** beliebige Workflows auf hochgeladene Dateien anwenden
** vertrauenswürdige, offline-fähige generative KI-Modelle einsetzen
** Funktionen genießen, die es in öffentlichen Diensten nicht gibt

=== Warum du deine Software nicht selbst hosten solltest

Self-Hosting ist komplexer und zeitaufwendiger als das Bezahlen für die gleiche Funktionalität – besonders am Anfang.
Es erfordert Disziplin und Geduld, wie das Erlernen eines neuen Instruments (aber dieses Instrument spielt irgendwann von selbst!).

Wenn etwas kaputtgeht, bist du die Person, die es repariert.
Manchmal bekommst du eine hilfreiche Fehlermeldung, manchmal findest du im Web eine schnelle Lösung.
Manchmal bekommst du keine – und kannst auch keine finden.

CAUTION: Wenn dir Fehlersuche und Debugging keinen Spaß machen, ist Self-Hosting vielleicht nichts für dich.

Wenn du nicht sorgfältig mit ((Backups)) und Sicherheit umgehst, riskierst du Zeit, Energie und das Vertrauen von Menschen, die dir wichtig sind.

(((HVAC)))
Self-Hosting vor Ort bringt zusätzliche physische Überlegungen mit sich.
Du musst für ausreichende Stromversorgung, Konnektivität, HVAC (Heizung, Lüftung und Klimatisierung) und Sicherheit sorgen.
Stell deinen Server einfach nicht draußen ab.

== Praktische Beispiele

Ich verwende täglich viele verschiedene Softwaretools.
Ich muss etwas nachschlagen, eine Fahrt organisieren, Essen kaufen und so weiter.
Viel von dieser Software ist leider ziemlich nervig!
Sie scheint immer mehr von meiner Zeit, Aufmerksamkeit und meinem Geld zu wollen – dabei will ich doch nur das praktische Ergebnis erreichen, bei dem sie mir angeblich helfen soll.
Deshalb vertraue ich ihr immer weniger und überlege ständig, wie ich sie durch etwas ersetzen kann, das ich lieber mag und dem ich mehr vertraue.

Hier sind ein paar Beispiele, bei denen ich einen öffentlichen Dienst durch eine selbstgehostete Lösung verbessert habe – gefolgt von einigen Überraschungen, auf die ich dabei gestoßen bin.

=== Criminal chickens

Meine Familie hat ein selbstgebautes Sicherheitssystem für unsere Hühner, und die Videos sind mir wichtig.
Früher habe ich sie einfach auf YouTube hochgeladen, weil hey, es ist kostenlos und es „funktioniert einfach“, oder?

Außer wenn es das nicht tut.
YouTube fand manchmal, dass meine Hühner Spam und/oder Betrug seien.

[#image-YT-censor]
.Screenshot einer E-Mail vom YouTube-Content-Team, welches mein Video von der Hühnerstall-Kamera entfernt hat.
image::YT-censor.png[align="center",scaledwidth=80%]

Nur fürs Protokoll: Unsere Hühner sind _blitzsauber_.

[#image-squeaky-clean-chicken]
.Eine absolut rechtschaffene, fleißige, gesetzestreue Henne.
image::squeaky-clean-chicken.png[align="center",scaledwidth=50%]

Als ich meine persönliche Cloud eingerichtet hatte, fühlte ich Freiheit und Leichtigkeit beim Posten und Hosten dieser Videos.
Ich musste keine YouTube-Formulare mehr ausfüllen, nur um meine Hühner im Blick behalten zu können.
Ich kann deren Prüfung und die fälschliche Behauptung eines Richtlinienverstoßes nun getrost ignorieren.

[#image-YT-audit]
.Screenshot einer YouTube-Rechtsprüfung für meinen alten API-Client.
image::YT-audit.png[align="center",scaledwidth=80%]

Ich muss auch nicht mehr mit der YouTube-API (Application Programming Interface) arbeiten, einschließlich der Registrierung eines API-Clients und der Durchführung regelmäßiger Prüfungen.
Nachdem ich Nextcloud eingerichtet hatte, habe ich meinen YouTube-API-Client zum Hochladen von Videos gelöscht, meinen Code bereinigt und die Wartung vereinfacht.
Es stellt sich heraus, dass die Nextcloud Talk API sowieso einfacher ist, um Fotos und Videos von meinem Hühnerstall zu posten.

Mit meiner eigenen Cloud kann ich auch Quoten und Geschwindigkeitsbegrenzungen nach Belieben anpassen.
Volle Fahrt voraus!

=== Fotosuche nach Standort

Hier ist noch ein Beispiel, das für eine persönliche Cloud spricht.
Dieses hat funktioniert, weil ich es gewohnt bin, Standort-Metadaten in meinen selbstgehosteten Fotos zu speichern.

Vor einiger Zeit wollte ich bestimmte Fotos aus einem Haufen von Tausenden finden, die mehrere Terabyte Speicherplatz belegten.
Ich wusste, wo ich war, als ich die Fotos gemacht habe (auf etwa 10 Meilen genau), aber ich konnte mich nicht erinnern, wann sie aufgenommen wurden.

Meine Fotos sind einfach eine Sammlung von JPEG-Dateien.
Ich habe sie mit einem kleinen Python-Programm untersucht, das ich selbst geschrieben habe.
Ich suchte nach allen Fotos, die im Umkreis von 10 Meilen um den Punkt aufgenommen wurden, den ich kannte.
Der Schlüssel war, direkt und schnell auf die Daten zugreifen zu können.

Das ist nur ein (wahrscheinlich bald veraltetes) Beispiel.
Wenn du das hier liest, kannst du deine Fotos vielleicht schon mit einem Satz wie „Zeig mir alle Fotos, die im Umkreis von 10 Meilen um Mexiko-Stadt aufgenommen wurden“ abfragen – und es funktioniert einfach.

Dann kannst du dich der Rettung der Welt widmen.
Stell nur sicher, dass du deine Daten hast!

=== Überraschungen

Falls du dich entscheidest, weiterzumachen: gute Reise, Reisende*r.
Das hier macht wirklich Spaß.

Du wirst vielleicht überrascht sein, wie schnell und einfach manche Dinge beim Self-Hosting funktionieren.
Ich würde zu gern erfahren, wie es bei dir läuft.

Du wirst vielleicht aber auch überrascht sein, wie zeitaufwendig und schwierig manche Dinge sein können.
Vielleicht hängst du an der Hardware fest (und deren Stromversorgung, Verkabelung, Kühlung, Ausfällen).
Vielleicht am Netzwerk.
Vielleicht am „Change Management“ (deine Nutzer*innen davon zu überzeugen, Nextcloud statt Dropbox zu verwenden).

Hier sind einige Dinge, die mich überrascht haben – im Positiven wie im Negativen.

==== Gute Überraschungen

===== Hardware war gar nicht so schwierig

Mit Hilfe eines Freundes (danke, Rob!) habe ich einen zuverlässigen und günstigen, generalüberholten Server gekauft.
Ich dachte, ich müsste an Kabeln, Karten und CMOS-Batterien herumbasteln.
Aber nein!
Ich habe das Gehäuse geöffnet, um einen Blick ins Innere zu werfen.
Ich konnte bestätigen: ganz normale Server-Innereien – oder zumindest nah genug dran.
Die CPUs und RAM-Riegel waren wie angekündigt vorhanden.

Ich habe ihn eingesteckt – und er hat funktioniert.

[#image-inside-chassis]
.Blick ins Innere des Servers mit zwei leeren PCI-E-Steckplätzen.
image::inside-chassis.jpg[align="center",scaledwidth=80%]

===== Containers == happy

(((Docker)))
Ich war angenehm überrascht von ((Container))s (erklärt in <<Contained services>>), insbesondere nach meinen gemischten früheren Erfahrungen mit VMs.
VMs sind anfangs einfach, weil sie sich wie echte Hardware verhalten.
Linux in eine VM zu installieren ist genauso einfach wie auf ((bloßes Metal)) (manchmal sogar einfacher).
Dann kann man einen oder mehrere Dienste in der VM einrichten.
Der eigentliche Haken liegt in der Wartung:
Das Pflegen einer VM kann genauso aufwendig sein wie die Wartung eines Bare-Metal-Servers.

Container verfolgen einen anderen Ansatz und simulieren deutlich weniger von einem Bare-Metal-Server.
Sie sind im Vergleich zu VMs schneller und ressourcenschonender, was eine höhere, konfliktfreie Dichte von Diensten ermöglicht.
Das heißt: Du kannst mehr Dienste pro Server betreiben, ohne dass sie sich gegenseitig stören (z.B. weil sie unterschiedliche Versionen von PHP benötigen).
Ein Container enthält in der Regel genau einen Dienst.

(((Isolation)))
Die Isolierung von Containern ist im Vergleich zu VMs begrenzt.
Zum Beispiel wird der Kernel (der Teil des Betriebssystems, der direkt mit der zugrunde liegenden Hardware kommuniziert) gemeinsam genutzt.
Diese begrenzte Isolierung hält jedoch die Ressourcen- und Wartungskosten bei containerbasierter Isolierung deutlich niedriger als bei VMs.

Container eignen sich hervorragend für eine konsistente und stabile persönliche Cloud.
Sie lassen sich leicht deklarieren (im Code), bauen, bereitstellen, testen und reproduzieren.
Container können auch zusammen mit VMs verwendet werden: Du könntest zum Beispiel eine VM als Server nutzen, anstelle von bloßes Metal.

Ich habe mich für Docker zur Verwaltung von Containern entschieden, weil es weit verbreitet ist und ich Erfahrung damit habe.
Dein Server wird dabei auch als Host bezeichnet, da er die Docker-Container hostet.

Ein Nachteil von Docker ist, dass in Beispielcode und öffentlichen Images oft Root-Zugriff vorausgesetzt wird.
Das Ausführen als `root` vereinfacht Container zwar, macht sie aber auch unsicherer.

===== Papierlos mit OCR

Eine weitere fortschrittliche Entwicklung, die ein Lächeln wert ist, ist kostenlose OCR (optocal character recognition/ optische Zeichenerkennung).
Ich versuche immer wieder, „papierlos zu werden“, indem ich all meine Papierdokumente einscanne.
Nach dem Scannen bleibe ich – wenig überraschend – mit einem Haufen PDF-Dateien voller Bilder zurück.
(((Paperless-ngx)))
Diese lassen sich ganz einfach mit Tools wie https://docs.paperless-ngx.com/[Paperless-ngx] und https://apps.nextcloud.com/apps/fulltextsearch[Nextcloud Full text search]  per OCR verarbeiten und verwalten.

===== Jellyfin funktioniert gut

((Jellyfin)) ist ein persönlicher Streaming-Medienserver.
Ich war begeistert zu sehen, wie Jellyfin sich als ausgezeichnete und vollständige FOSS-Alternative zu ((Plex)) herausgestellt hat.

==== Schlechte Überraschungen

===== Traefik-Lernkurve

Der ((Traefik))-Reverse-Proxy war überraschend herausfordernd einzurichten, da meine Netzwerkgrundlagen etwas eingerostet waren.
Ich habe ihn nun zuverlässig zum Laufen gebracht, muss aber mein grundlegendes Netzwerkwissen weiterhin verbessern.
Siehe <<Reverse-Proxy>> für mehr Informationen über Traefik.

===== Nextcloud Bugs

(((Nextcloud, surprises with)))
Ich war frustriert über einige Probleme in Nextcloud.
Diese fühlten sich besonders dringend an, da ich stark darauf angewiesen bin.

Der Community-Support ist mal gut, mal weniger gut.
Nextcloud scheint außerhalb der USA populärer zu sein.

Nicht alle Nextcloud-Apps sind schon ausgereift.
Mehr unter <<Personalisierung>>.

===== Jitsi and Ports

((Jitsi)) ist eine selbstgehostete FOSS-Videokonferenzplattform.
Ich habe aufgegeben, Jitsi in Docker zum Laufen zu bringen.
Ich erinnere mich, dass viele offene Ports oder Portbereiche ein Problem waren.
Dieser Dienst könnte leichter in einer virtuellen Maschine selbst gehostet werden.

Es gibt auch eine Umgehungslösung, bei der Portbereiche bestimmten IP-Adressen zugewiesen werden, aber das geht über den Umfang dieses Buches hinaus.
Ich werde es irgendwann nochmal versuchen, weil https://jitsi.org/blog/authentication-on-meet-jit-si/[logging in is now required when using the free 8x8-hosted Jitsi service].

==== Nimm sie alle auf

Wenn es um Überraschungen geht, versuche die schlechten zu verkraften, wenn sie deine Nutzer betreffen.
Im Idealfall _bevor_ sie deine Nutzer betreffen, durch Recherche, Planung und Tests, die du wahrscheinlich schon machst.

(((dogfooding)))
Nutze selbst, was du selbst hostest.

Gib dein Bestes, um alles attraktiv und nützlich zu gestalten, und warte dann ab.
Sei geduldig.
Versuche niemals, Menschen zu zwingen, das zu nutzen, was du selbst hostest.

Ich hoffe, dieses Buch inspiriert dich mit vielen positiven Überraschungen und hilft dir und deinen Nutzern, viele negative zu vermeiden.

== Planung

Wir werden jetzt kurz die wichtigsten Punkte eines Selbsthosting-Plans durchgehen.
Ich liebe diesen Teil!
Ich freue mich auf das, was kommt, und ich weiß, dass ein solider Plan eine Vision Wirklichkeit werden lässt.

Mach _deinen_ Plan.
Pflege und verbessere deinen Plan gemeinsam mit deinem Server.
Teile den Plan mit anderen Administrator*innen.

Ja, anderen Administrator*innen.
Du brauchst jemanden, der dich vertreten kann, wenn du nicht verfügbar bist, oder eine glasklare Erwartung, dass der Server mit dir stirbt.

=== Budget

Berücksichtige die Zeit und die Kosten des Selbsthostings – für dich selbst _und deine Nutzer*innen_.
Wie viel hast du zur Verfügung und wie viel möchtest du ausgeben? Schreib eine Zahl auf und halte dich daran.

=== Ressourcen

Skizziere deine Gedanken zu den Ressourcen, die du benötigen wirst.
Einige Ideen:

Rechenleistung und Speicher::
CPU und RAM sind die grundlegenden Ressourcen, die für die Berechnung notwendig sind.
Siehe <<Dienste Ressourcen zuordnen>> für Ideen, wie du Anforderungen basierend auf den Diensten, die du hosten wirst, abschätzen kannst.
GPU-Arbeitslasten werden in diesem Buch nicht behandelt, obwohl <<_whats_next>> und <<Übungen>> einige Dinge ansprechen, die du selbst ausprobieren kannst.

Datenspeicher::
Schätze, wie viel Speicherplatz du benötigen wirst.
Mit jedem Sprung in der Einheit (zum Beispiel von GB (Gigabyte) zu TB (Terabyte)) steigt die Komplexität und die Kosten deutlich an.
Dieses Buch ist für Datenspeicher bis etwa 10 TB geeignet.
Siehe <<Festplattenlaufwerke>> für Tipps, wie du beim Speicher durch Self-Hosting Geld sparen kannst.

Strom::
Überprüfe deine Stromrechnung auf die Kosten pro kWh und mache einige Berechnungen.
Siehe <<Server>> für ein Beispiel, wie viel Strom ein leistungsfähiger Server verbraucht.

Support::
Wer hilft dir, wenn du mal nicht weiterkommst?
<<Support>> bietet einige Ideen.

Physischer Standort::
Wo soll der Server stehen?
Musst du neue Leitungen für Strom oder Netzwerk verlegen?
<<Networking>> beschreibt meine Heiminstallation.

=== Zeitlicher Ablauf

Skizziere grob wichtige Termine, damit du und deine Nutzer vorausplanen können.
Zum Beispiel:

28.{nbsp}April::
  Brainstorming, Planung.
30.{nbsp}April::
  Hardware bestellen.
3.{nbsp}Mai::
  Ethernet-Kabel vom Router in die Garage verlegen.
5.{nbsp}Mai::
  Server einrichten: Festplatten einbauen, einschalten, Betriebssystem installieren, Dienste starten.
9.{nbsp}Juni::
  Ergebnis im Vergleich zu den ursprünglichen Zielen überprüfen.

Lade andere ein, mitzumachen, idealerweise schon zu Beginn beim Brainstorming und der Planung.
Das ist eine großartige Gelegenheit, weitere Personen einzubeziehen, die bei der Betreuung des Servers helfen können.

=== Umstellung

(((change management)))
Ihre Benutzer haben ihre Daten bereits an einem anderen Ort.
Überlegen Sie, wie Sie ihnen helfen können, ihre Daten auf den Server zu migrieren.

Der Schlüssel dazu ist ausgezeichnete Kommunikation.
Nehmen Sie dies in Ihren Plan auf und sorgen Sie für Zustimmung, da die Migrationskosten bei jeder Umstellung eine Realität sind.

TIP: Um mehr darüber zu erfahren, wie man Benutzer sanft zwischen Systemen überführt, beschäftigen Sie sich mit dem Thema _Change Management_.

=== Sysadmin Mindset

(((sysadmin, mindset of a Steadfast)))
Der Server existiert für die Nutzer.
Es ist wichtig, die richtige Einstellung zu haben, um eine hervorragende Nutzererfahrung bieten zu können.

Stelle sicher, dass deine selbstgehosteten Dienste gut für deine Nutzer funktionieren.
Bitte sie regelmäßig um Feedback und nimm es ernst.
Unterscheide sorgfältig zwischen ihren _Wünschen_ und ihren _Bedürfnissen_.

Übersetze das Wort „Nutzer“ je nach Kontext passend.
Vielleicht: „die dir am meisten am Herzen liegen, die du über alle anderen hinweg am meisten schätzt, diejenigen, die dir Sinn und Zweck geben.“
Ja, das ist etwas übertrieben.
Du verstehst den Punkt: Wir müssen aufmerksam sein, was die Nutzer erleben, sonst wird es für alle frustrierend.

Ideal ist es, wenn du deine Nutzer bereits im echten Leben kennst.
Bleibe auch im echten Leben mit ihnen in Verbindung, um sie online besser unterstützen zu können.

== System Design

Tauchen wir ein in die Gestaltung eines _Steadfast_ Systems.

=== Dienst-Stack

Ein _Steadfast_ System lässt sich gut als vereinfachter Stapel farbiger Kästchen darstellen.
Die vertikale Anordnung dieses Stacks richtet sich danach, wo und wie häufig eine Systemadministratorin wahrscheinlich auf dieser Ebene agieren oder bei Support- oder Fehlersuche eingreifen wird (am häufigsten oben), sowie danach, wie stark die jeweilige Ebene vom bloßes Metal abstrahiert ist (am wenigsten unten).

[#image-service-stack]
.Schichten eines Steadfast systems. Von unten, Hardware: bloßes Metal, Dateisystemsystem: ext4 for / and optionally ZFS for /data, Betriebssystem: Ubuntu LTS 64-bit server, Containerlaufzeit: Docker, Container: Nextcloud Dateifreigabe, Jellyfin Medienserver, Wallabag Artikelleser.
image::service-stack.svg[align="center",scaledwidth=80%]

Am häufigsten arbeite ich in den oberen Schichten – zum Beispiel beim Hinzufügen oder Aktualisieren eines Containers.
Seltener aktualisiere ich Betriebssystempakete.
Noch seltener sehe ich mir Versionen einer Konfigurationsdatei an, die auf der Festplatte gespeichert sind – dank automatischer Snapshots von ZFS.
Und schließlich, wenn mein Server ausfällt, befinde ich mich ganz unten im Stack: Ich repariere oder ersetze die Hardware.
Hier findest du die entsprechenden Abschnitte mit Details zu jeder Ebene:

* Dienste in Containern:
** <<Nextcloud: Dateisynchronisation und -Freigabe>>
** <<Jellyfin: Audio- und Videostreaming>>
** <<Wallabag: Artikel speichern und lesen>>
* container runtime:
** <<Containers == happy>>
** <<Contained services>>
* OS: <<Betriebssystem>>
* filesystem: <<Dateisystem>>
* hardware: <<Server>>

Es gibt außerdem zwei Dienste in Containern, die später behandelt werden und _nicht_ im Diagramm dargestellt sind:

* <<Watchtower: Dienst-Updates>>
* <<Scratch: visuelle Programmierung>>

=== Digitale Sicherheit

Lass uns die grundlegenden Werkzeuge kennenlernen, um deinen Server zu verstehen und abzusichern.

==== Categoriziere deine Daten

Zuerst solltest du deine Daten betrachten.
Es hilft, sie in zwei gängige Kategorien aufzuteilen:

===== Sensible Daten

Beispiele: Passwörter, Kreditkartennummern, staatliche Ausweisnummern.
Empfehlungen:

. Wenn möglich, nur offline speichern.
. Falls jemals auf einem Computer gespeichert, dann verschlüsselt.
. Einfache Lösung: in einem ((Passwortmanager)) speichern.

===== Alles Andere

Beispiele: Notizen, Fotos, Dokumente, persönliche Informationen.
Empfehlungen:

. Auf verschlüsselten Medien speichern, einschließlich Backups.
. Nur mit aktueller, vertrauenswürdiger Software darauf zugreifen.
. WAN-Zugriff (Wide Area Network) auf diese Daten untersagen.

==== WAN-Zugriff

(((WAN-Zugriff)))
Sobald du deine Daten kategorisiert hast, überlege dir, wie Menschen darauf zugreifen werden.
Zuhause kannst du im Allgemeinen direkt auf deinen Server zugreifen.
Wenn du jedoch unterwegs bist oder Daten mit jemand anderem teilen möchtest, geht es um WAN-Zugriff (Wide Area Network).

(((Router)))
(((port forward)))
WAN-Zugriff ist – informell gesagt – der Fernzugriff auf Dienste und Daten, die in deinem lokalen Netzwerk (LAN) laufen.
Eine Möglichkeit, WAN-Zugriff auf einen Dienst zu ermöglichen, ist das Weiterleiten von HTTPS-Verkehr (Portweiterleitung) über deinen Router oder deine Firewall.
Portweiterleitung ohne zusätzliche Sicherheitsmaßnahmen ist zugleich riskant und bequem.

NOTE: Ziehe Alternativen zur Portweiterleitung in Betracht, wie etwa die Verwendung einer VPN.

==== Bedrohungsmodell

(((threat model)))
Gehen wir einen Schritt zurück und sprechen über Bedrohungsmodellierung.
Dein Bedrohungsmodell beschreibt, wie du Bedrohungen für deine Daten einschätzt und wie du ihnen entgegenwirken willst.
Mit einem klaren Bedrohungsmodell kannst du fundierte Entscheidungen treffen – zum Beispiel darüber, ob du den WAN-Zugriff auf deinen Server erlauben solltest oder nicht.

WARNING: Wenn du bereits weißt, dass du ein wertvolles Ziel bist (z.B. öffentliche Person, hohes Vermögen, Kriegsberichterstatter*in oder verantwortlich für einen Server mit Informationen über viele Menschen), dann gilt: Mach dich auf eine längere Reise gefasst.
Dieses Buch allein reicht nicht aus, um deinem Bedrohungsmodell gerecht zu werden.

Lass uns ein einfaches Beispiel für ein Bedrohungsmodell für die Datenklasse "alles andere" erstellen.
Überlege dir dabei folgende Punkte:

Anlagen::
  Daten, die du schützen möchtest.
Akteure / Bedrohungen / Angriffsvektoren::
  Menschen und Bots, die in böser Absicht handeln – sowie deren Angriffsmethoden.
Auch unbeabsichtigte Fehler und Software-Bugs zählen dazu.
Gegenmaßnahmen::
  Maßnahmen zur Risikominimierung, damit Angriffe weniger wahrscheinlich sind oder weniger Schaden anrichten.

Füg das alles zusammen, und du erhältst mein absolut marketingfreundliches Akronym für ein Bedrohungsmodell: *A.A/B/A.G.* (jede Zeichensetzung wird mitgesprochen).
Geht einem wirklich leicht über die Lippen!

==== Beispiel: WAN-Zugriff

Teste ((WAN-Zugriff)) mit diesem Bedrohungsmodell.

Anlagen::
  Dateien mit persönlichen Informationen, die in einem veralteten Dienst gespeichert sind (z.B. eine alte, verwundbare Version von Nextcloud).
Akteure / Bedrohungen / Angriffsvektoren::
  Ein Bot durchsucht Websites und findet eine URL zu einem Dienst in einem öffentlich zugänglichen Mailinglisten-Archiv.
Der Bot versucht automatisch, eine bekannte Schwachstelle im Dienst auszunutzen.
Der Angriff gelingt, und der Bot-Betreiber erhält Zugriff auf Rechenressourcen und persönliche Informationen.
Gegenmaßnahmen::
  Halte den Dienst aktuell.
Sichere die WAN-Grenze: überwache die Verkehrsdaten, setze ein ((IPS)) (Intrusion Prevention System (Einbruchsschutzsystem)) ein, und lasse den Zugriff ins ((LAN)) nur über ein VPN (Virtual Private Network) zu.
Schließe die WAN-Grenze: erlaube keinen eingehenden WAN-Zugriff.

Solltest du dich entscheiden, einen Dienst öffentlich zugänglich zu machen, helfen diese Maßnahmen, ihn zu sichern.
„Öffentliche Mailinglisten vermeiden“ ist nicht als Maßnahme aufgeführt, da es nur die URL zum veralteten Dienst verschleiert und man sich nicht auf „Sicherheit durch Verschleierung“ verlassen sollte.

[%unbreakable]
TIP: Die Absicherung auf mehreren Ebenen (Betriebssystem-Firewall, Dienst, WAN-Grenze) zeigt das Prinzip der „Verteidigung in der Tiefe“ („defense in depth“), eine gängige und sinnvolle Sicherheitsstrategie.

==== VPN

Ein ((VPN)) kann deine WAN-Grenze absichern, indem es nur authentifizierte Benutzer zulässt und eine Verschlüsselungsschicht hinzufügt.
So kannst du dich sicher in dein ((LAN)) „teleportieren“, während du remote bist.

Wenn alle deine Nutzer ein VPN verwenden können, kannst du die Ports für HTTP/S-Verkehr geschlossen halten und stattdessen nur VPN-Verkehr erlauben.
Vorausgesetzt, dein VPN-Server ist gut konfiguriert und aktuell, ist dies eine hervorragende Möglichkeit, deine ((Angriffsfläche)) zu reduzieren.

Die VPN-Technologie erhielt ein großes Upgrade durch https://www.wireguard.com[Wireguard].
Aus Nutzersicht gibt es keinen schweren Login-Prozess mehr, wie bei älteren VPNs.
((Wireguard)) ist schnell, einfach und sicher.

==== Full-disk Verschlüsselung

(((verschlüsselung, full-disk)))
Das Verschlüsseln verhindert, dass ein Angreifer Daten wiederherstellen kann.
Beim Hochfahren musst du allerdings ein Passwort eingeben.
Das ist unpraktisch, wenn es zu Stromausfällen kommt und/oder keine Fernverwaltung möglich ist.
Außerdem wird zu Recht argumentiert, dass Vollplattenverschlüsselung für einen ständig eingeschalteten Server wenig bringt: Im Normalbetrieb hast du den Entschlüsselungsschlüssel ja bereits eingegeben.

Wenn du dich für Vollplattenverschlüsselung entscheidest, wähle sie während der <<OS-Installation>> aus.
Sieh dir die vorherigen Abschnitte dieses Kapitels an, falls du bei der Entscheidung Unterstützung möchtest.

==== Mehr Tips

[#self-hoster-security-tips]
.Self-hoster Sicherheitstips
****
* Pflege nützliche, verschlüsselte Backups.
Führe Test-Wiederherstellungen durch, um deren Nützlichkeit zu bestätigen.
Siehe <<Backups>>.
* Vermeide es, Befehle als root-Benutzer auszuführen.
* Nutze Multi-Faktor-Authentifizierung.
* Setze Firewalls ein.
* Verwende starke Passwörter.
* Sei sehr vorsichtig beim Port-Forwarding oder lasse es am besten ganz weg.
* Sei wachsam bei all den üblichen Dingen: Phishing, Malware, SMS-Spoofing und Social-Engineering-Angriffen.
** Sei vorsichtig mit Links und Anhängen in E-Mails.
** Installiere keine nicht vertrauenswürdige Software. Always use HTTPS.
** Nutze bei deinem Mobilfunkanbieter eine spezielle Passphrase als zusätzliche Authentifizierungsebene.
** Hinterfrage Dringlichkeit und verdächtige Anfragen kritisch.
* Leite unbekannte Anrufe auf die Mailbox um.
* Achte auf Datenpannen und schütze deine Identität.
** Sperre deine Kreditinformationen nach einem Datenleak.
* Informiere dich über Kompartimentierung (Isolation) und das Prinzip der geringsten Privilegien.
****

Zusätzliche Lektüre:

* https://oreilly.com/library/view/personal-cybersecurity-how/9781484224304/[Personal Cybersecurity: How to Avoid and Recover from Cybercrime] by Marvin Waschke
* https://modernprivatelife.com/how-to-choose-privacy-threat-model/[Personal Privacy Threat Modeling (With LOTS Of Examples)] by Eliza
* https://arstechnica.com/information-technology/2017/07/how-i-learned-to-stop-worrying-mostly-and-love-my-threat-model/[How I learned to stop worrying (mostly) and love my threat model] by Sean Gallagher

=== Dateisystem

(((ZFS)))
Ich empfehle (und werde demonstrieren), mit einem einzigen ((ext4))-Dateisystem zu beginnen und optional einem ZFS-Dateisystem.
ext4 ist das stabile, einfache und standardmäßige Dateisystem für Ubuntu.
ZFS (ursprünglich: Zettabyte File System) bietet Verschlüsselung, leichte Snapshots und ((RAID)) (redundante Anordnung kostengünstiger Festplatten).

Optional kannst du ZFS für den Speicher (`/data`) auf deinem Server verwenden, wie unter <<ZFS Setup>> beschrieben.
Für die Root-Partition (`/`) empfehle ich stattdessen ext4 zu verwenden, um:

* So nah wie möglich an der Standard-Ubuntu-Installation bleiben
* Docker-Dateisystem-Müll vermeiden
** Wenn `/var/lib/docker` auf ZFS liegt, werden viele Docker-bezogene Dateisysteme erstellt, die die Ausgabe von `zfs list` etwas unübersichtlich machen
* ZFS-Snapshots des Betriebssystems vermeiden, da
** wir sie nicht brauchen
** das Betriebssystem außerhalb der ZFS-Verzeichnisse liegt
** wir das Betriebssystem nicht verändern werden – Änderungen werden upstream verwaltet (z. B. bei Paketupdates oder über mario)

Docker-Volumes (nachhaltige Container-Daten) werden auf ZFS gespeichert.
Das Dateisystem des ((Container)) – also alles außer den gemounteten Volumes mit nachhaltigen Daten – ist flüchtig (ephemeral) und liegt auf ext4 unter `/var/lib/docker`.
Um mehr über ZFS zu erfahren, siehe:

* https://arstechnica.com/information-technology/2014/01/bitrot-and-atomic-cows-inside-next-gen-filesystems/[Bitrot and atomic COWs: Inside „next-gen“ filesystems] by Jim Salter
* https://arstechnica.com/information-technology/2020/05/zfs-101-understanding-zfs-storage-and-performance/[ZFS 101—Understanding ZFS storage and performance] by Jim Salter
* https://wiki.debian.org/ZFS[ZFS (Debian wiki page)] by various authors

Weitere ZFS-Konzepte, die es sich zu lernen lohnt: Fragmentierung, ARC (Adaptive Replacement Cache), Resilvering, Scrubbing, `ashift` und `recordsize`.

=== Betriebssystem

(((Betriebssystem)))
(((Ubuntu)))
((Linux)) ist eine beliebte und vernünftige Wahl für Self-Hosting. Ich empfehle einen 64-Bit-Ubuntu-Linux-Server mit mindestens 2 GB Arbeitsspeicher und 30 GB Speicherplatz.
Ubuntu ((LTS)) (Long-Term Support)-Versionen sind am stabilsten, und ich empfehle genau diese.
Steadfast bezieht sich speziell auf 24.04, die LTS-Version von April 2024.
Version 24.04 ist heute stabil und https://ubuntu.com/about/release-cycle[wird bis April 2034 Updates] erhalten, was viele weitere Jahre Stabilität verspricht, bevor Steadfast überarbeitet werden muss.
Die Installation des Betriebssystems ist im Allgemeinen schnell und schmerzlos, siehe <<OS-Installation>>.

==== Personalisierung

Es ist gute Praxis, Anpassungen am Betriebssystem möglichst gering zu halten und sorgfältig zu dokumentieren, wenn man von einer Standardinstallation ausgeht.
Das erleichtert die Wartung, einschließlich eventueller Neuinstallationen.
Nicht ständig am Server herumzubasteln erfordert Disziplin, besonders für altgediente, hands-on Systemadministratoren wie mich.

Versuche, es zu vermeiden, dich per SSH direkt auf den Server einzuloggen und dort Einzeländerungen vorzunehmen.
Du wirst lernen, stattdessen die Konfigurationsdateien von mario zu bearbeiten und den Server neu zu provisionieren (siehe <<_mario>>).

Natürlich kannst und solltest du dich weiterhin per ((SSH)) auf den Server verbinden, aber versuche dann, nur Lesezugriffe oder nur ausnahmsweise Schreibzugriffe auszuführen.
Ich mache oft erst etwas manuell, mache es rückgängig und erledige dann denselben Schritt mit mario, um sicherzustellen, dass das Ergebnis wie erwartet ist.

****
Beispiele für serverseitige Leseoperationen:

* Ressourcenverbrauch pro Container anzeigen: `sudo docker stats`
* Container-Logmeldungen verfolgen (ausführen im Verzeichnis mit einer `compose.yml`-Datei): `sudo docker compose logs -f`
* Server-Gesundheit prüfen: `date; tail /proc/pressure/*`

Beispiele für serverseitige Schreiboperationen:

* Betriebssystem-Pakete aktualisieren: `sudo apt full-upgrade`
* Berechtigungen für einen Ordner ändern: `chmod 0700 ~/bin/`
****

Beginne mit einer Checkliste für die „monatliche Wartung“, wie sie in <<Serverwartung>> zu finden ist.
Nimm diese schreibenden (read-write) Operationen in deine Checkliste auf.
Führe schreibende Operationen nach Möglichkeit mit mario durch.

Verwende stets `sudo`, um privilegierte Befehle auszuführen, anstatt dich direkt als `root` anzumelden.
So wird jeder Befehl zusammen mit Zeitpunkt und ausführender Person in `/var/log/auth.log` protokolliert.

Upgrades können automatisiert werden.
Das ist sinnvoll, sobald man eine gewisse Skalierung erreicht hat – vorausgesetzt, man hat Vertrauen in und Kontrolle über die Quelle der Updates.
Ich persönlich führe Betriebssystem-Upgrades meist manuell durch, da ich nur wenige Systeme betreue. Der Aufwand ist dadurch gering und selten, und das Aktualisieren eines Pakets kann Tests oder manuelle Eingriffe (z.B. einen Neustart) erfordern.
Aus ähnlichen Gründen installiere ich auch das Betriebssystem selbst von Hand.

Mein Betriebssystem ist eher ein Haustier als ein Nutztier (siehe „cattle vs. pets“ im <<Glossary>>).
Vielleicht ist es sogar ein Haustier-Phönix:
Wenn es stirbt, lässt es sich relativ leicht aus der Asche wiederbeleben.
Es wird regelmäßig gesichert, es gibt nur wenige manuelle Schritte – und alle manuellen Schritte sind sorgfältig dokumentiert.

=== Contained services

mario nutzt ((Docker)) um Dienste in Containern zu betreiben.
Docker ist bur eine von vielen Wegen um Dienste isoliert zu betreiben.
((VM))s werden auch oftmals fur diese Zwecke genutzt.
Siehe <<Containers == happy>> fur einen Vergleich dieser zwei Optionen.
Falls du weiteres Interesse VMs hast (als Alternative oder im Zusammenhang mit Containern), schaue bei https://proxmox.com[Proxmox] vorbei.

((Kubernetes)) funktionieren auch gut um Dienste zu betreiben.
Probiere Kubernetes aus (vorallem eine der interessanten Micro-Versionen) falls du vertrauter oder interessierter an dieser Version bist.
Ich persoenlich fand es zu viel.
Falls ich aber hohe Verfügbarkeit fur Clustering benötigte wurde ich eher Kubernetes nutzen.
Falls einer der Computer des Kubernetes ((Cluster)) defekt ist können Dienste automatisch auf intakte Hardware im Cluster übertreten.
Unabhängig von deiner Wahl solltest du mit deinen Nutzern klare Erwartungen darüber setzten, wie lange dein Server im Falle eines Defektes eventuell ausfallen kann.

(((isolation)))
Docker schafft eine gute Balance zwischen Eigenschaften und Benutzerfreundlichkeit, weshalb es einfach ist einen Deinst in Isolation zu betreiben.
((Docker Compose)) Docker Compose erweitert Docker um die Fähigkeit, Gruppen von Prozessen zu definieren und auszuführen, die zusammen einen vollständigen Dienst bereitstellen (z.B. einen Webserver und dessen Datenbank).
Kubernetes kann das auch – und noch viel mehr, das du _nicht_ lernen musst, solange du _kein_ virtuelles Rechenzentrum aufbauen willst.
Für ein einzelnes Serversystem ist Docker Compose meist die passendere Wahl.

Es ist außerdem ratsam, Dienste und deren Abhängigkeiten _nicht_ mit allem anderen auf dem primären Speicher des Servers zu vermischen.
Anfangs erscheint es einfach, alles auf einem einzigen Dateisystem zu betreiben – besonders, wenn es nur einen Dienst gibt.
Doch je mehr Dienste hinzukommen, desto komplizierter wird es.
https://en.wikipedia.org/wiki/Dependency_hell[Doch je mehr Dienste hinzukommen, desto komplizierter wird es].

Viele der verzweifelten Supportanfragen von Self-Hostern, die ich in FOSS-Communities sehe, betreffen Inkompatibilitäten zwischen bestimmten PHP-Versionen oder relationalen Datenbankversionen, die von zwei verschiedenen Diensten benötigt werden.
Docker mildert dieses Problem, indem es Abhängigkeiten bündelt.
Jedes Docker-Image ist im Grunde ein vollständiges Dateisystem (ohne Kernel), sodass ein Service-Image immer die passende PHP-Version enthält.
Ein anderes Image wird bei Bedarf für die Datenbank verwendet.

Es lohnt sich, einen Moment bei den gebündelten Abhängigkeiten zu verweilen.
Wenn Abhängigkeiten Kleidung wären, dann ist ein Docker ((Container)) ein robuster und günstiger Koffer mit allem, was man für eine Woche Reise braucht.
Man gibt seinen Koffer ab, steigt in den Zug und kann beruhigt sein, dass der Koffer ordentlich und getrennt neben den anderen verstaut ist.
Docker-Container sind Koffer – während die alte Herangehensweise einem riesigen Wäschehaufen im letzten Waggon entspricht, in dem alle ihre ungefaltete Kleidung einfach hineingeworfen haben.

(((image)))
Container werden aus Images erstellt.
Ein Image ist der Bauplan, mit dem sich ein neuer Koffer (Container) wie durch Magie erschaffen lässt – fix und fertig gepackt mit der passenden Kleidung für deine Reise.
Ein Image wird einmal erstellt, mit einer eindeutigen Kennung versehen und weitergegeben.
Es dient dann als Grundlage für unzählige Container, die sich zuverlässig gleich verhalten.

Images werden über eine Datei namens `Dockerfile` definiert.
Die `Dockerfile` sollte in der Versionskontrolle (z.B. Git) verfolgt werden.
Da mario Docker-Compose verwendet, ist eine weitere wichtige Datei `compose.yml`.
Jeder Dienst hat seine eigene `compose.yml` Datei, die ebenfalls unter Versionskontrolle stehen sollte.
Für Systemadministratoren bieten diese Konventionen ((reproduzierbare)) Images und Container.
Für Benutzer bedeutet das: verlässliche, vorhersehbare Dienste.

(((cattle vs. pets)))
Übe den Umgang mit Containern als temporäre Objekte.
Du gewinnst Vertrauen in dein System, indem du Container regelmäßig erstellst und wieder entfernst – und du wirst die Geschwindigkeit und Einfachheit dieses Vorgehens schätzen lernen.
Denke so:

* Kurzlebig
** Container sind temporär
** Temporäre Container ermöglichen robuste, reproduzierbare Dienste
* Nutztiere, keine Haustiere
** Von Hand verwaltete virtuelle Maschinen sind aufwendige Haustiere
** Entschuldigung an das Vieh – in diesem Vergleich sind sie entbehrlich
* Zustandslos
** Permanente Daten müssen explizit definiert und verwaltet werden
* Phönix-Server
** Ein Begriff von Kornelis Sietsma für Server, die regelmäßig zerstört und neu erschaffen werden

=== Reverse-Proxy

Ein ((Reverse-Proxy)) sitzt vor den Containern und leitet den Datenverkehr anhand beliebiger Regeln an den richtigen Dienst weiter.

Angenommen, du hast die Domain example.com gekauft und möchtest Nextcloud unter cloud.example.com und Jellyfin unter jellyfin.example.com betreiben.

Dein Server verwendet dann einen Reverse-Proxy und eine einzige IP-Adresse, um den eingehenden Datenverkehr je nach Hostnamen an den jeweiligen Dienst weiterzuleiten.

mario verwendet Traefik als Reverse-Proxy.

==== Traefik Architektur

Hier ein Überblick darüber, wie ((Traefik)) funktioniert und wie es mit Nextcloud und anderen selbstgehosteten Webdiensten zusammenarbeitet:

Wir möchten, dass ((HTTPS))-Anfragen an Port 443, die für cloud.example.com bestimmt sind, beim Nextcloud-Dienst ankommen.
Um diesen Vorgang zu verstehen, hilft es, das mitgelieferte Traefik-Architekturdiagramm zu studieren – ebenso wie die Quelltexte von mario.

[#image-traefik-architecture]
. Traefik-Architekturdiagramm, das zeigt, wie eine Anfrage einen Dienst erreicht.Aus dem MIT-lizenzierten Quellcode von Traefik. Danke an Peka für das Gopher-Logo, lizenziert unter CC-BY-3.0.
image::traefik-architecture.png[]

(((router, Traefik)))
In den mario-Quelltexten (oder in den später gezeigten Codeausschnitten) lohnt sich ein Blick in die compose.yml-Dateien für Traefik und Nextcloud, in denen unter anderem Folgendes enthalten ist:

* Der websecure-Eintrittspunkt, über den HTTPS-Verkehr auf Port 443 empfangen wird
* Die App-Service-Definition für Nextcloud, die Traefik-Routing-Labels enthält
* Die Host(…)-Regel im nc-https-Router, mit der eingehender Verkehr basierend auf dem Hostnamen weitergeleitet wird

[%unbreakable]
NOTE: Die Symbole `app`, `websecure` und `nc-https` sind willkürlich gewählt.
Ich habe kurze Namen verwendet, damit sie nicht über Zeilen umbrechen.
Du kannst stattdessen auch längere, beschreibendere Namen verwenden.

Die Routing-Labels verknüpfen den Entrypoint und den Router mit dem Dienst, unter dem sie definiert sind.
Konkret heißt das: `websecure` → `nc-https` → `app`.

Die folgenden beiden Snippets aus dem Mario-Quellcode zeigen, wie wir Traefik für Nextcloud einrichten.

.Traefik-Konfigurationsausschnitt (🏠 Admincomputer)
[source#traefik-config,yaml]
----
# from traefik/compose.yml
services:
  reverse-proxy:
    command:
      - --entrypoints.websecure.address=:443 <1>
----

<1> Definiere den Entrypoint `websecure` im Dienst `reverse-proxy`, der Datenverkehr über Port 443 entgegennimmt.

.Nextcloud-Konfigurationsausschnitt (🏠 Admincomputer)
[source#nextcloud-config,yaml]
----
# from nextcloud/compose.yml
services:
  app:
    labels:
      - "traefik.http.routers.nc-https.entrypoints=websecure" <1>
      - "traefik.http.routers.nc-https.rule=Host(`cloud.example.com`)" <2>
----

<1> Verbinde den Entrypoint `websecure` mit dem Router `nc-https` im Dienst `app`.

<2> Verwende die Hostnamen-Regel mit dem Router `nc-https`.

Jeder selbst gehostete Dienst wird über einen eigenen Router verfügen.
Auch andere Webdienste verwenden den `websecure`-Zugang.

Die HTTPS-Verschlüsselung wird über weitere Labels am Traefik-Container konfiguriert.
Siehe <<Verschlüsselungszertifikate>> für Details.

== Implementierung

Nun sind wir bereit, die ersten drei Schichten im <<Dienst-Stack>> bereitzustellen: Hardware, Dateisystem und Betriebssystem.
Ich beginne damit, Werkzeuge zur Bewertung von Diensten bereitzustellen und fahre dann mit der Installation des Betriebssystems und der Serverwartung fort.

=== Dienstplan

Als Dienste bezeichnet man die dauerhaft laufenden Softwareprogramme auf deinem Server.
Einige bieten eine Benutzeroberfläche, andere laufen im Hintergrund nach einem Zeitplan.
„Webdienste“ sind jene, auf die du über einen Webbrowser oder ein anderes Tool, das HTTP verwendet, zugreifen kannst.

==== Dienstwahl

Beginne damit, deine bisherigen Anforderungen und Pläne zu überprüfen, und nutze das folgende Material, um fundierte Entscheidungen darüber zu treffen, welche Dienste du betreiben möchtest.
Du kannst auch direkt zu <<Hardware vorbereiten>> springen, um dem vorgeschlagenen Pfad zu folgen und zunächst die Dienste zu verwenden, die mario standardmäßig installiert. Später kannst du zu diesem Abschnitt zurückkehren, wenn du weitere Dienste hinzufügen möchtest.

===== Geeignet fürs Self-Hosting

Du wirst feststellen, dass sich manche Dienste deutlich besser fürs Self-Hosting eignen als andere.
Die guten Dienste weisen in der Regel zumindest einige der folgenden Merkmale auf:

.Merkmale eines guten selbstgehosteten Dienst
[#traits-of-good-services]
****
* Einfach zu installieren, mit vorhandenen Anleitungen für das Selbst-Hosting
* Kompatibel mit deiner bevorzugten Bereitstellungsmethode (z.B. gut gepflegtes Docker-Image, Anleitungen für Docker Compose und Traefik)
* Aktive Community mit moderierten Chats, Foren, Mailinglisten, News und Meetups
* Aktuelle Entwicklung sichtbar (z.B. neue Releases, Commits, Ankündigungen)
* Nutzung einer FOSS-Lizenz (Freie und Open-Source-Software)
* Transparente Angaben zu Eigentümern und Sponsoren
* Öffentliche Roadmap, Issue-Tracking, Continuous Integration, öffentliches Demo, Build-Skripte, Bug-/Security-Bounties
* Bei Problemen lassen sich über Websuche leicht Informationen finden (z.B. bekannte Issues oder Workarounds)
* Gut strukturierter, sauberer Code
* Nützliche und aktuelle Dokumentation
* Vergleicht sich offen mit ähnlichen Projekten
* Vollständig dokumentierte, nützliche API
* Flexibel und erweiterbar (z.B. über Plugins oder Konfigurationsoptionen)

****

Siehe auch <<solution-viability-checklist>> in <<Alternativen zu mario>>.

Diese Merkmale basieren sowohl auf gängigen Branchenstandards als auch auf meinen persönlichen Werten und Vorlieben.
Deine eigene Liste kann sich davon unterscheiden – zum Beispiel, wenn du FOSS-Lizenzen weniger bevorzugst oder eine bestimmte Programmiersprache bevorzugst.

===== Ungeeignet fürs Self-Hosting

Hier sind einige Hinweise darauf, dass ein selbst gehosteter Dienst möglicherweise vermieden werden sollte.

.Merkmale eines schlechten selbstgehosteten Dienst
[#traits-of-bad-services]
****
* Unbeliebt, inaktiv oder schlecht gepflegt:
** Wenige Maintainer oder Beitragende
* Maintainer reagieren kaum auf Beiträge der Community
* Enthält Telemetrie (verbindet sich nach Hause, sammelt Statistiken oder Nutzungsdaten) – besonders ohne deine Zustimmung und/oder standardmäßig aktiviert
* Hat bekannte Sicherheitslücken
* Verwirrende oder undurchsichtige Organisation: Governance, Entwicklungsplan, Lizenzierung, Versionskontrolle, Beitragseinreichung, Fehlerverfolgung
* Übermäßig komplex
* Schwer zu forken (weiterzuentwickeln)
* Nur auf Unternehmen ausgelegt: Selbsthosting-Anleitungen fehlen oder sind sehr kompliziert
* Häufige, störende Werbung oder Kaufaufforderungen
* Bewusste Herstellerbindung (Vendor Lock-in)
* Abhängigkeit von geschlossenen/proprietären Standards oder Diensten
* https://de.wikipedia.org/wiki/Open-Core-Modell[Open-Core-Modell]

****

(((Nextcloud)))
Ich werde hier Nextcloud ein wenig kritisieren.
Nextcloud hat deutlich mehr positive als negative Eigenschaften – aber diese Punkte sind trotzdem erwähnenswert.

(((fork)))
Zunächst ihr offenbar nicht-FOSS-kompatibles Build-Skript.
https://help.nextcloud.com/t/build-bzip-and-package-from-git/58341/2[Nicks Erklärung] dafür ist nachvollziehbar:
Es ist für sie bequemer, Geheimnisse direkt im Build-Skript zu hinterlegen und das gesamte Skript geheim zu halten.
Aber: Hardcodierte Geheimnisse sind schlechte Praxis, das Verstecken eines Build-Skripts könnte ein Verstoß gegen die AGPL-Lizenz sein,
und es erschwert das Forken.
Es ist gute Praxis, die Nachfolge zu visualisieren – also vorbereitet zu sein auf ein Forking und einen möglichen Eigentümerwechsel.
Nextcloud selbst ist schließlich ein Fork von ((ownCloud)) (siehe <<Nextcloud vs. ownCloud>>).

Zweitens: die ausufernde Komplexität.
„Nextcloud“ ist kein einzelnes Projekt, sondern eine Sammlung von _vielen_ Softwareprojekten und Diensten,
die in unterschiedlichem Maße von einem einzigen Unternehmen kontrolliert werden.
Diese Komplexität macht einen Fork teuer und zeitaufwendig.
Selbst der Wechsel zwischen bestehenden Forks (zum Beispiel die Rückkehr von Nextcloud zu ownCloud) kann kompliziert sein.
Es ist offensichtlich, dass sie _nicht_ versuchen, Nutzer absichtlich an sich zu binden –
aber die Komplexität an sich kann letztlich genau diesen Effekt haben.

==== Dienste Ressourcen zuordnen

Hier ist eine frühe, grobe Tabelle zur Ressourcenplanung, die ich verwendet habe.
Du kannst dieses Schema nutzen, um deinen eigenen Ressourcenbedarf abzuschätzen.
Einige dieser Dienste werden später im Buch noch im Detail behandelt.

[%unbreakable,cols="4,4,3,2,2",id=example-tally]
.Beispielhafte Aufstellung von Diensten und benötigten Hardware-Ressourcen
|===
|Dienst |Zweck |Isolation |Cores |RAM

|jellyfin |Musik Streaming |Docker |2 |2 GB
|kahoot-clone |Quizspiele |Docker |0 |0 GB
|poller |Umfragen |Docker |0 |0 GB
|backuppc |Backups |none |0 |0 GB
|taskd |Aufgabenmanagement |Docker |0 |0 GB
|sftp |Dateiübertragung |none |0 |0 GB
|syncthing |Dateisynchronisation |none |1 |1 GB
|nextcloud |Dateifreigabe |Docker |2 |2 GB
|minetest |Spieleserver |Docker |4 |8 GB
|irssi |Chatprogramm |none |0 |0 GB
|jitsi |Videoanrufe |Docker |2 |2 GB
|wallabag |Artikelspeicher |Docker |1 |1 GB
|===

„Cores“ steht für den relativen Spitzenbedarf an Rechenleistung.
RAM bezeichnet den maximalen Speicherbedarf.
Diese Werte waren grobe Schätzungen, basierend auf veröffentlichter Dokumentation.
Die Schätzungen erwiesen sich als hinreichend genau.
Mir wurde schnell klar, dass ich etwas Leistungsfähigeres brauchen würde als den damals neuesten verfügbaren Raspberry Pi.
Siehe <<Server>> für weitere Erkenntnisse zu den Anforderungen an Ressourcen.

=== Hardware vorbereiten

Es heißt __Hard__ ware, weil diese Probleme _hard_ (schwierig) sind.
Das klingt zwar lustig, entspricht aber meiner Erfahrung nach nicht der Wahrheit.
Auch wenn es eine gewisse Lernkurve beim Verstehen der grundlegenden Computerhardware gibt und Hardware durchaus ausfallen kann, hat sie viele wunderbare, positive Seiten. Zum Beispiel:

* Hardware ist greifbar und verhält sich in der Regel konsistent.
* Einfach einstecken, einschalten – und es funktioniert höchstwahrscheinlich.
* Wenn es funktioniert, ist das sehr befriedigend.

==== Server

Du brauchst einen Server.

(((compute)))
Du kannst zwar jederzeit Rechenleistung in der Cloud eines anderen mieten, aber auf lange Sicht wird das teurer.

Wenn du es eilig hast, kannst du mit fast jedem alten Desktop oder Laptop anfangen – oder mit deiner eigenen VM, die irgendwo läuft.
Verwende aber besser etwas Leistungsfähigeres und Erweiterbareres als einen Raspberry Pi.
Was, wenn deine Nutzer begeistert sind?
Wie wirst du den Speicherplatz erweitern?
Was passiert bei plötzlichen Lastspitzen?
Wenn du mit etwas zu Kleinem startest, fehlt es dir schnell an Geschwindigkeit und Erweiterbarkeit.

Ich habe bereits mit vielen verschiedenen Servern gearbeitet und mich für dieses Self-Hosting-Abenteuer gründlich vorbereitet. Daher hatte ich eine ziemlich klare Vorstellung davon, was ich wollte.
Ich habe mich für etwas entschieden, das leistungsstark, günstig und schnell ist – mit viel Speicherplatz und Raum für Erweiterungen.
Ich habe gezielt nach professioneller Standardhardware gesucht, weil sie im Fall eines Defekts leichter austauschbar ist.
Der Server sollte mit plötzlichen Lastspitzen gut zurechtkommen, z.B. beim Bauen von Docker-Images, bei kurzfristig hoher Benutzeraktivität oder auch bei etwas generativer ((KI)) – selbst ohne GPU.

Ich habe auf eBay einen gebrauchten, generalüberholten 1U-Rackmount-Server für etwa 1.000USD gefunden.
Solche Geräte werden oft als „off-lease enterprise hardware“ bezeichnet – also Leasing-Rückläufer aus dem Unternehmensbereich.
Ein 1U-Server ist ein https://de.wikipedia.org/wiki/Rack-Einheit[Rack Unit] hoch – etwa so groß wie eine lange Pizzaschachtel.
Technologiekonzerne stoßen diese Geräte massenweise ab, sodass man oft ein gutes Angebot findet.
Mein Server hat zwei 24-Kern-CPUs und 128GB RAM.

[#image-racked-server]
.Selbstgebauter Rackmount-Server, an der Garagendecke montiert.Macht Spaß, ihn anzuschauen, und er ist aus dem Weg – aber für Wartungsarbeiten brauche ich eine Leiter, und er wiegt etwa 23kg.
image::racked-server.jpg[align="center"]

Die Lüfter sind viel lauter als bei einem Desktop-PC, besonders unter Last.
Der Server soll eigentlich eine gute Belüftung sowie Temperatur- und Feuchtigkeitsregulierung haben,
hat sich aber bisher auch bei längeren Zeiträumen unter dem Gefrierpunkt und über 38°C als äußerst robust erwiesen.
(((IPMI)))
Er verfügt über mehrere Enterprise-Funktionen, die die Wartung erleichtern – wie redundante Netzteile, Hot-Swap-Festplatteneinschübe, zahlreiche Sensoren und Fernwartung über einen Webbrowser oder IPMI.

Der durchschnittliche Stromverbrauch liegt bei 130W, also etwa 1.140kWh pro Jahr – das entspricht ungefähr 138,15$ in Seattle.
Das ist in etwa so viel wie eine helle Glühlampe verbraucht, und für eine einzelne Person etwas verschwenderisch.
Aber bei fünf Nutzer*innen? Etwa 228kWh pro Jahr und Person.
Das ist _weniger_ als der Stromverbrauch der Cloud-Server-Infrastruktur, die nötig ist, um ein einziges mobiles Gerät über Googles oder Apples Cloud-Dienste zu versorgen.
Weitere Literatur zu diesem Thema:

* https://science.time.com/2013/08/14/power-drain-the-digital-cloud-is-using-more-energy-than-you-think/[The Surprisingly Large Energy Footprint of the Digital Economy] by Bryan Walsh
* https://theguardian.com/sustainable-business/2014/sep/10/energy-consumption-behind-smart-phone[The spiralling energy consumption behind your smart phone] by Betsy Reed
* https://increment.com/energy-environment/the-secret-energy-impact-of-your-phone/[The secret energy impact of your phone] by Owen Williams

Ein Rackmount-Server wie meiner kann weit mehr als fünf Nutzer*innen bedienen –
vorausgesetzt, sie versuchen nicht alle gleichzeitig, Videos zu transkodieren.

Außerdem eignet er sich hervorragend als beheizte Sitzstange.

[#image-bird-on-server]
.Vogel auf einem Server sitzend.
image::bird-on-server.jpg[align="center",scaledwidth=50%]

==== Admincomputer

(((Admincomputer)))
Es ist hilfreich, einen separaten Computer vom Server zu haben, um Änderungen vorzunehmen.
Ich verwende normalerweise ein Laptop als Admincomputer, um mario zu betreiben.

==== Testgeräte

Deine Nutzer*innen werden ihre eigenen Computer und Mobilgeräte (ihre _Clients_) verwenden.
Halte ein paar verschiedene Clients bereit, damit du vergleichbare Umgebungen hast und deinen Nutzer*innen besser helfen kannst.

(((dogfooding)))
TIP: Sei selbst Nutzer*in der Dienste, die du betreibst.
Das nennt man _Dogfooding_.
Dogfooding sorgt dafür, dass du ehrlich mit dir selbst bleibst und dich besser in andere hineinversetzen kannst.

==== Festplattenlaufwerke

(((ZFS, snapshots and)))
Ich verwende Festplattenlaufwerke (Hard Disk Drives ((HDDs))) zur Datenspeicherung – hauptsächlich, um Kosten gegenüber öffentlichem Cloud-Speicher oder ((SSD))s (Solid-State-Laufwerken) zu sparen.
Die Kosten für ((Blockspeicher)) in der Public Cloud übersteigen bei Weitem die Gigabyte-Stunden-Kosten meiner Festplattenlaufwerke.
Ich habe den Preis für einen 5TB Blockspeicher bei AWS auf 228,10 $ pro Monat geschätzt.
Mit ZFS erstelle ich außerdem alle 15 Minuten einen Snapshot (im Grunde ein vollständiges lokales Backup).
Der monatliche Preis für stündliche Snapshots (das nächstvergleichbare Angebot, das ich finden konnte) kostet weitere 310,68$ bei AWS.
Das ergibt 535,67$ gesamt – also etwa so viel, wie ich für meine Festplatten ausgegeben habe.
Ich hatte meine Ausgaben also nach einem Monat wieder drin – und die Festplatten sollten _jahrelang_ halten.

(((RAID)))
Zur Redundanz empfehle ich, zwei identische Festplatten im Spiegelmodus (RAID 1) zu verwenden.
Das bietet nicht nur Datensicherheit bei Ausfall einer Festplatte, sondern auch bessere Leseleistung (bei den meisten Lesezugriffen).
Beachte aber: Die nutzbare Speicherkapazität wird dabei halbiert.

((HDDs)) sind völlig ausreichend schnell, wenn man die Antwortzeiten selbstgehosteter Dienste als Maßstab nimmt. Das Betriebssystem und die Dienste arbeiten effizient mit Daten-Caching, sofern der Server über ausreichend RAM verfügt.
Remote-Backups können länger dauern – das ist in Ordnung.

Ich verwende eine SSD für das Betriebssystem und alles außerhalb meiner Fotos/Dokumente usw., da die Startzeit des Betriebssystems entscheidend ist und dieses beim Booten nur wenig von Dateisystem-Caching profitiert.

(((data sovereignty)))
Eine interessante Alternative zu Festplatten für bestimmte Anwendungsfälle ist Object Storage.
Dabei handelt es sich um einen skalierbaren, cloudbasierten, unstrukturierten Key-Value-Speicher,
den das Betriebssystem nicht direkt nutzen kann – Nextcloud allerdings schon.

Bei der Entscheidung zwischen beiden Optionen gibt es viele Faktoren zu beachten, zum Beispiel:

* Kosten für Speicherung und Egress (Downloads)
* Kontrolle, Autonomie und Datenhoheit
* Softwareunterstützung für Object Storage
* Direkter Zugriff auf die Daten
* Zugriffsgeschwindigkeit und -methoden
* Netzwerkverfügbarkeit
* Backups, Versionierung und Sicherheit

Ich habe mich für HDDs entschieden, um direkten, lokalen Zugriff auf meine Daten zu haben.
Ich wollte ganz genau wissen, wo sie gespeichert sind, und maximale Flexibilität haben, wenn ich Dienste wechsle oder neue ausprobiere.
Außerdem benötigen die meisten meiner Dienste ohnehin direkten Zugriff auf die Daten.

==== Networking

Wenn du zu Hause hostest und auch von anderen Orten als deinem lokalen Netzwerk (LAN) aus auf deinen Server zugreifen möchtest, brauchst du eine zuverlässige WAN-Verbindung (Wide Area Network).
Verwende für deinen Server unbedingt kabelgebundenes Ethernet statt WLAN.
Ein verkabeltes LAN ist zuverlässiger und deutlich einfacher zu warten und zu diagnostizieren.

===== Mindestanforderungen

(((ISP)))
Hier sind einige typische Mindestanforderungen für das Self-Hosting zu Hause:

* 100 Mbit/s Upload / 100 Mbit/s Download bei deinem Internetanbieter
* Cat-5-Ethernetkabel (für die Verbindung deines Servers)
* 802.11ac-WLAN (für deine Client-Geräte)

Ich habe diese Werte auf Grundlage meiner eigenen Erfahrungen zusammengestellt – und dann verdoppelt, damit du etwas Spielraum für Wachstum hast.

===== Konfiguration des Heimrouters

Lerne, wie du deinen ((Router)) richtig konfigurierst.
Halte seine Firmware aktuell und pflege eine strikte ((Firewall)): Öffne bzw. leite nur die Ports weiter, die wirklich nötig sind.

[%unbreakable]
CAUTION: Portweiterleitung ermöglicht eingehende Verbindungen durch deine WAN-Grenze zu deinem Server.
Lies unbedingt <<Digitale Sicherheit>>, bevor du irgendwelche Ports weiterleitest.

Erstelle eine Skizze, um dein Netzwerk besser zu verstehen.
Hier ist ein einfaches Diagramm, das ich mit https://asciiflow.com erstellt habe, um die Verkabelung zu planen und den Datenfluss durch meine Netzwerkgeräte zu visualisieren:

ifdef::backend-html5,backend-pdf[]
[#image-WAN-to-LAN-traffic]
.WAN into LAN traffic flow diagram.
image::WAN-to-LAN-traffic.svg[align="center",scaledwidth=80%]
endif::[]
ifdef::backend-epub3[]
[#image-WAN-to-LAN-traffic]
.WAN into LAN traffic flow diagram.
image::WAN-to-LAN-traffic.png[,472,320,align="center"]
endif::[]

(((IPMI)))
Pfeile stellen Ethernet-Kabel dar.
Der Router versorgt den Mini-Switch über PoE (Power over Ethernet) mit Strom.
Der Server verfügt über zwei Netzwerkkarten (NICs – Network Interface Cards): eine für das Betriebssystem und alle darauf laufenden Dienste, und eine für die Netzwerkverbindung zum eingebetteten OOB-Remote-Management-Computer mit IPMI (Intelligent Platform Management Interface).
WAN-Verkehr darf zur Haupt-NIC fließen, jedoch _nicht_ zur IPMI-NIC.

==== Stromversorgung

Verwende eine Steckdosenleiste mit Überspannungsschutz.
Falls deine Stromversorgung zu Hause unzuverlässig ist, solltest du eine USV (unterbrechungsfreie Stromversorgung) in Betracht ziehen.

==== Physische Sicherheit

Schütze deinen Server wie andere Wertsachen in deinem Zuhause.
Mindestens solltest du den physischen Zugang einschränken.

=== OS-Installation

Hier ist eine Anleitung zur Einrichtung deines Servers.
Die Installation des Betriebssystems dauert etwa fünf Minuten, wenn alles reibungslos verläuft.
Schritte werden der Kürze halber weggelassen, wenn die Voreinstellung ausreicht.

NOTE: Während du das Betriebssystem installierst, denke bereits an die Notfallwiederherstellung.
Mache dir Notizen und stelle dir vor, wie du den Vorgang exakt wiederholst.
Bei jedem Schritt im interaktiven Ubuntu-Installer: Akzeptiere entweder die Voreinstellung oder notiere dir deine Auswahl.

. *Installiere Ubuntu* 24.04 LTS server.
Siehe https://ubuntu.com/tutorials/install-ubuntu-server[this tutorial] für eine Schritt-für-Schritt Anleitung.
. Verwende beim Konfigurieren des Netzwerks eine *statische LAN-IP-Adress*.
YDu kannst dies möglicherweise auch auf dem Standardwert belassen (DHCP/dynamisch) und stattdessen deinen LAN-Router so konfigurieren, dass er dem Server eine feste IP-Adresse zuweist, die sich nicht ändert.
. Optional: Verwende eine vollständige Festplattenverschlüsselung.
Siehe <<Full-disk Verschlüsselung>>.
. *Notiere Username und Passwort* wenn du deinen Nutzeraccount ("Profile") erstells. Du wirst sie bald brauchen.
. *Installiere den OpenSSH Server* wenn du dazu aufgerufen wirst.
. *Installiere kein Nextcloud oder Docker*, lasse mario diese später installieren.

Glückwunsch, du hast soeben Linux installiert!
Der nächste Schritt:

. Optional: Nachdem du Ubuntu installiert hast, füge zwei weitere Festplattenlaufwerke hinzu und formatiere sie mit ZFS.
Siehe <<ZFS Setup>>.
. Lade mario auf deinen Admincomputer herunter. Siehe <<Weitere Ressourcen>>.
. nutze mario auf deinem Admincomouter um deinen Server bereitzustellen. Siehe <<_mario>>.

==== ZFS Setup

(((ZFS, setting up)))
Das Betriebssystem kümmert sich im Allgemeinen gut um sich selbst.
Für eine robustere Datenspeicherung kannst du ein paar HDDs hinzufügen und sie mit **ZFS** verwalten.

ZFS bietet viele Funktionen und etwas zusätzliche Komplexität.
Die Lernkurve lohnt sich.

Die folgende Anleitung zeigt dir, wie du einen einfachen Pool aus zwei gespiegelten Festplatten erstellst, sichtbar unter `/data`.
Das ist ein sinnvoller Ausgangspunkt: Du erhältst damit bessere Fehlertoleranz und schnellere Leseleistung als mit nur einer einzelnen Festplatte.

Auf dem Server führst du diese Befehle als `root` aus (Tipp: zuerst `sudo su -` eingeben).
Der Code unten geht davon aus, dass du mit einer Festplatte für das Betriebssystem angefangen hast, und dass das Betriebssystem diese als `/dev/sda` erkannt hat,
und dass du zwei weitere Festplatten hinzugefügt hast, die als `/dev/sdb` und `/dev/sdc` erkannt wurden.
Passe das bei Bedarf an — verwende `lsblk`, um deine Laufwerke zu identifizieren.

// Dieser Codeausschnitt ist von Vim mit `textwidth=75` umgebrochen, da das zufällig den aktuellen Seitenrändern des gedruckten Buchs entspricht.😬

.ZFS Setup (🚀 server)
[source#zfs-setup,bash]
----
# Create partition tables.
parted /dev/sdb mklabel gpt
parted /dev/sdc mklabel gpt

# Create ZFS main mirrored pool and set attributes (for all future datasets
# in this pool).
zpool create -O mountpoint=none main mirror /dev/sdb /dev/sdc
# For performance.
zfs set atime=off main
# To save space.
zfs set compression=on main
# For security.
zfs set exec=off main
zfs set setuid=off main
zfs set canmount=off main

# Create encrypted dataset in "main" pool. This is the "parent" dataset, we
# can easily add more later and they'll all be encrypted.
openssl rand -base64 32 > /root/secure-dataset-key
zfs create -o encryption=on -o keyformat=passphrase \
    -o keylocation=file:///root/secure-dataset-key main/secure
zfs set canmount=off main/secure

# Create usable (mount-able) dataset.
zfs create -o mountpoint=/data main/secure/data

# This might not be necessary if you _never_ want to execute anything in
# /data. I found I needed it for something within a container (ffmpeg, I
# think). You can start with exec=off and turn it on later if you want.
zfs set exec=on main/secure/data
----

Hier sind einige Befehle, mit denen du Details zu dem anzeigen kannst, was du gerade erstellt hast.
Dafür sind keine Root-Rechte erforderlich.

.show ZFS details (🚀 server)
[source#zfs-details,bash]
----
# Examine pools.
zpool status
zpool list

# Examine datasets.
zfs list
----

Unter Ubuntu 24.04 LTS sind weitere Schritte erforderlich, damit dieses neue Dateisystem beim Serverstart automatisch eingebunden wird.
Die folgenden Anweisungen stammen aus der Handbuchseite zfs-mount-generator(8) — mit einigen Korrekturen.
Diese Befehle müssen mit Root-Rechten ausgeführt werden.

.ZFS mount on boot setup (🚀 server)
[source#zfs-mount-on-boot,bash]
----
# enable tracking for the pool
mkdir /etc/zfs/zfs-list.cache
touch /etc/zfs/zfs-list.cache/main

# enable the tracking ZEDLET
systemctl enable zfs-zed.service
systemctl restart zfs-zed.service

# trigger cache refresh
zfs set relatime=off main/secure
zfs inherit relatime main/secure

# re-run systemd generators and reboot
systemctl daemon-reload
reboot
----

=== Serverwartung

(((maintenance, server)))
Ich verwende kurze monatliche und jährliche Wartungs-Checklisten.
Ich aktualisiere meine Checklisten ungefähr so oft, wie ich sie benutze.
Hier sind Beispiele, die du als Ausgangspunkt verwenden kannst.

.Checkliste: Monatliche Wartung
[%unbreakable#monthly-maintenance]
****
* [ ] Betriebssystempakete aktualisieren.
* [ ] Verfügbaren Speicherplatz überprüfen.
* [ ] Router-Konfiguration sichern.
****

Beachte, dass Ubuntu Server standardmäßig das Paket `unattended-upgrades` enthält, das Sicherheitsupdates automatisch installiert.
Du möchtest stattdessen vielleicht den Punkt „Bestätigen, dass Betriebssystem-Updates erfolgreich waren“ in deine Checkliste aufnehmen.

Jährliche Aufgaben sind in der Regel aufwändiger und betreffen Teile des Systems und seiner Abhängigkeiten, die sich idealerweise seltener ändern.

.Checkliste: Jährliche Wartung
[%unbreakable#yearly-maintenance]
****
* [ ] Backups wiederherstellen testen.
* [ ] Threat Model überprüfen und verbessern.
* [ ] Servergehäuse öffnen und tote Spinnen wegsaugen.
****

Die folgenden Abschnitte enthalten spezifische Wartungstipps und -tricks.

==== Hardware-Ausfall

Plane mit Hardware-Ausfällen.
Wenn du es dir leisten kannst, ist der einfachste Weg, einen Server zuverlässig zu betreiben, _zwei identische Server zu kaufen_.
Verwende den zweiten als Ersatzteilspender oder als sofort einsatzbereiten Ersatz (auch „Cold Spare“ genannt).

==== SSoftware-Updates

Halte deinen Server auf dem neuesten Stand.
Für das Betriebssystem:

.upgrade packages (🚀 server)
[source#upgrade-packages,bash]
----
sudo apt update && sudo apt full-upgrade
----

Dies aktualisiert die lokalen Paketinformationen und – falls erfolgreich – das Betriebssystem.
Root-Zugriff ist erforderlich, daher sudo.
Das ist relativ sicher und erfordert in der Regel wenig bis keine Interaktion außer einer Bestätigung zum Fortfahren.
Ein Neustart kann anschließend nötig sein (z.B. bei Kernel-Updates).
Beim Einloggen zeigt der Server an, ob ein Neustart erforderlich ist.

Jeder Dienst in <<Dienste>> enthält einen Abschnitt „Wartungshinweise“ mit Update-Anleitungen.
Container-Images lassen sich manuell mit ((Docker Compose)) oder automatisch mit ((Watchtower)) aktualisieren.
Siehe <<Watchtower: Dienst-Updates>> für Details.

==== Überwachung

Behalte die Server-Gesundheit im Blick.
Prüfe den freien Speicherplatz mit df -h.
Wenn sich der Server träge anfühlt, überprüfe die PSI (Pressure Stall Information) mit:

.check PSI (🚀 server)
[source#check-psi,bash]
----
tail /proc/pressure/*
----

atop zeigt ebenfalls PSI-Werte an.
Wenn dein PSI-Check hohe Ressourcennutzung anzeigt, versuche docker stats, um die Ressourcennutzung pro Container zu sehen.
Das sollte dir helfen, das Problem auf bestimmte Dienste einzugrenzen.

Wenn du ZFS verwendest, kannst du zpool iostat verwenden, um Ein-/Ausgabe-Statistiken für deine Speicherpools zu sehen.

Auf Host-Ebene kannst du htop -d 100 verwenden, um Statistiken für alle Prozesse und Threads zu sehen.
Verfolge alle protokollierten Ereignisse für den Host mit journalctl -f.

==== Backups

Nützliche Backups zu haben ist eine entscheidend wichtige Praxis, für die man selten Anerkennung bekommt, wenn sie gut gemacht ist – aber immer Schuld, wenn sie schlecht gemacht ist.

Überprüfe regelmäßig deine Backups, um sicherzustellen, dass sie funktionieren.

(((ZFS, snapshots and)))
Erstelle konsistente Backups von allem auf deinem Server, sodass die laufenden Dienste nicht einmal bemerken, dass sie gesichert werden.
Beispiel: Erstelle einen ZFS-Snapshot und sichere diesen.

Backups mithilfe von ZFS-Snapshots können trotzdem Probleme verursachen.
ZFS garantiert beispielsweise keinen konsistenten Zustand der gesicherten Daten für laufende Programme.
Angenommen, du stellst eine MariaDB-Datenbank aus einem Backup wieder her.
Wenn du die Tabellen vor dem Erstellen des ZFS-Snapshots nicht geleert und gesperrt hast, könnte MariaDB gerade dabei gewesen sein, einen Schreibvorgang durchzuführen, mit Daten im Speicher, die noch nicht auf die Festplatte geschrieben wurden.
Sie müsste sich dann selbst wiederherstellen, und die Daten, die MariaDB zu schreiben versuchte, könnten verloren gehen.
Diese Art von Datenverlust ist selten, und das Risiko ist für ein typisches Homelab akzeptabel.

[%unbreakable]
TIP: Erstelle ((Backups)) nach der 3-2-1-Faustregel:
Erstelle *3* Backups. Bewahre mindestens *2* lokale Kopien auf unterschiedlichen Medien auf.
Habe *1* externes (remote) Backup.

(((backups, using restic for)))
(((backups, using Borg for)))
(((Borg)))
(((restic)))
Ich empfehle eine Backup-Strategie, die ZFS-Snapshots mit entweder https://restic.net[restic] oder https://borgbackup.org[Borg] kombiniert, um die Daten extern zu sichern.
https://reddit.com/r/BorgBackup/comments/v3bwfg/[Hier ist ein guter Vergleich zwischen restic und Borg].

Hier sind einige Beispielbefehle, die zeigen, wie man ein ZFS-Dateisystem sichert.
Du kannst sie als Ausgangspunkt für dein eigenes Backup-Skript verwenden.

.example backup script (🚀 server)
[source%unbreakable#example-backup-script,bash]
----
snapName=$(date -I)-backup

sudo zfs snapshot main/secure/data@$snapName <1>

sudo restic backup /data/.zfs/snapshot/$snapName <2>

sudo zfs destroy -R main/secure/data@$snapName
----

<1> Das Ausführen dieses Befehls zum Erstellen eines Snapshots dauert auf meinem Server 0,040 Sekunden.
Sobald er abgeschlossen ist, erscheint ein neuer schreibgeschützter Ordner unter /data/.zfs/snapshot, der den Snapshot enthält.

<2> Diese Zeile setzt voraus, dass du restic installiert und konfiguriert hast.
Es kann deinen Snapshot extern sichern – gemäß der 3-2-1-Regel.

== mario

(((Ansible)))
((mario)) ist ein Tool, das ich entwickelt habe, um dir beim Einrichten und Warten eines Servers zu helfen.
Es ist im Wesentlichen ein Wrapper um das bewährte https://ansible.com[Ansible-Systembereitstellungstool].
Alles, was ich mit mario mache, lässt sich auch manuell direkt auf dem Server erledigen.
Der Vorteil bei der Verwendung von mario ist jedoch, dass jede Änderung (z.B. die Installation eines Pakets) konsistent und mit Prüfprotokoll durchgeführt wird.
Der wahre Nutzen dieser Praxis zeigt sich vor allem bei der Zusammenarbeit mit anderen – einschließlich deinem zukünftigen Ich.
Es ist oft nicht leicht, sich ein Jahr später noch zu erinnern, was man getan hat und warum.

Sobald dein Server online ist, wie unter <<OS-Installation>> beschrieben, kannst du mario verwenden, um Dienste zu konfigurieren und zu starten.

Bitte lade den Quellcode herunter (siehe <<Weitere Ressourcen>>).
Es ist hilfreich, ihn griffbereit zu haben, um beim Lesen mitverfolgen zu können.

mario befindet sich zusammen mit diesem Buch im Ordner `mario/`.
Das Skript `provision.sh` befindet sich im Verzeichnis `ansible/`.

=== mario-Philosophie

mario ist ein praktisches Lernwerkzeug.
Es bringt sinnvolle, getestete Standardwerte mit.
Es automatisiert einige der mühsamen und verwirrenden Schritte beim Einrichten von Diensten auf einem Server.
mario ist kein unterstütztes und produktionsreifes Softwareprodukt.
Es bringt dich an den Start, das ist alles.
Mach damit weiter, wenn du möchtest – oder nutze es einfach, um den Aufbau deiner persönlichen Cloud zu beschleunigen.
Etwas anderes erfüllt seine Aufgabe besser oder wird es in Zukunft tun.
Hier sind einige Vorschläge, wie du das Beste aus mario herausholen kannst:

Beim ersten Ausführen von mario solltest du die Anweisungen so genau wie möglich befolgen.
Es werden viele Annahmen getroffen, damit es „out of the box“ funktioniert, und es ist leicht anpassbar gedacht.

Die Konfigurationsdateien von mario sind deklarativ:
Sie enthalten den Zustand, in dem sich dein Server am Ende befinden soll – nicht all die einzelnen Befehle, die du manuell ausführen würdest, um denselben Zustand zu erreichen.
marios `provision.sh` führt Ansible aus, und Ansible führt die Befehle für dich auf dem Server aus (z.B. ein chmod auf eine Datei) – auf vorhersehbare und wiederholbare Weise.
Der gewünschte Endzustand, wie in den Konfigurationsdateien deklariert, wird durch Ansible erreicht und bestätigt.

(((idempotent)))
(((provision)))
Nachdem mario einmal erfolgreich eingerichtet wurde, solltest du es direkt nochmal ausführen!
Das Provisionieren mit mario ist beruhigend idempotent:
Das System ändert sich nicht mehr in bedeutender Weise, sobald der gewünschte Zustand erreicht ist.
Sobald `provision.sh` erfolgreich abgeschlossen ist, kannst du es erneut ausführen, um zu bestätigen, dass sich der Server weiterhin im gewünschten Zustand befindet.
Dann kannst du anfangen zu experimentieren.
Einige Ideen findest du unter <<Übungen>>.

Wenn du dich mit VMs auskennst und lieber damit arbeitest, kannst du zunächst eine VM erstellen und mario darauf ausführen, bis du bereit bist, mario auf deinen echten Server loszulassen.
Oder vielleicht _ist_ dein echter Server eine VM – das funktioniert ebenso gut.

=== SSH Setup

mario läuft auf deinem ((Admin-Computer)) und erwartet, direkt per SSH eine Verbindung zu deinem Server herstellen zu können.
So bringst du das zum Laufen.

Weise zuerst der IP-Adresse deines Servers einen leicht zu merkenden Namen zu.
Füge mit der IP-Adresse aus <<OS-Installation>> eine Zeile wie diese in deine Hosts-Datei ein (z.B. /etc/hosts):

.line to add to hosts file (🏠 Admincomputer)
[source%unbreakable#line-for-hosts,text]
----
192.168.1.100	mario_server
----

Bestätige, dass du den Server unter dem Namen mario_server anpingen kannst.
So sieht es aus, wenn es funktioniert:

.test ping server (🏠 Admincomputer)
[source%unbreakable#test-ping-server,text]
----
$ ping mario_server
PING mario_server (192.168.1.100) 56(84) bytes of data.
64 bytes from mario_server (192.168.1.100): icmp_seq=1 ttl=64 time=0.316 ms
64 bytes from mario_server (192.168.1.100): icmp_seq=2 ttl=64 time=0.535 ms
64 bytes from mario_server (192.168.1.100): icmp_seq=3 ttl=64 time=0.178 ms
^C
--- mario_server ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2041ms
rtt min/avg/max/mdev = 0.178/0.343/0.535/0.146 ms
----

Als Nächstes soll dein SSH-Client beim Ausführen von ssh mario_server den richtigen Benutzernamen übermitteln.
Hier ist eine Beispielkonfigurationsvorlage für den ((OpenSSH))-Client.
Ersetze your-username durch den Benutzernamen deines Serverkontos.

.customize OpenSSH client configuration (🏠 Admincomputer)
[source%unbreakable#customize-openssh-client,text]
----
Host mario_server
  User your-username
----

Du kannst das in ~/.ssh/config einfügen und bei Bedarf an deinen verwendeten SSH-Client anpassen.
Teste die Verbindung mit ssh mario_server.
Du wirst möglicherweise so etwas sehen:

.SSH host fingerprint prompt (🏠 Admincomputer)
[source%unbreakable#ssh-host-fing,text]
----
Die Echtheit des Hosts »mario\_server (192.168.1.100)« kann nicht festgestellt werden.
Der ECDSA-Schlüssel-Fingerabdruck ist SHA256\:o2kUkvSP3JG9PTt/Ju11FWKkCpTJCB4rY3jQvImtRNw.
Möchten Sie die Verbindung wirklich herstellen (yes/no/\[fingerprint])?
----

Wenn die IP-Adresse korrekt ist, kannst du davon ausgehen, dass der Server im LAN, den du gerade erstellt hast, derselbe ist, mit dem du dich jetzt verbinden möchtest.
Fahre fort mit `yes` und `Enter`.
Wenn du ganz sicher gehen willst, führe einen der folgenden Befehle auf dem Server aus und überprüfe, ob die Fingerabdrücke übereinstimmen:

.show SSH host public key (🚀 server)
[source#show-ssh-host-pubkey,bash]
----
# use this if you saw "ECDSA key fingerprint..." earlier
ssh-keygen -lf /etc/ssh/ssh_host_ecdsa_key.pub

# use this if you saw "ED25519 key fingerprint..." earlier
ssh-keygen -lf /etc/ssh/ssh_host_ed25519_key.pub

# use this if you saw "RSA key fingerprint..." earlier
ssh-keygen -lf /etc/ssh/ssh_host_rsa_key.pub
----

Als Nächstes richte die Authentifizierung mit öffentlichem Schlüssel ein.
Wenn du ein Schlüsselpaar benötigst, erstelle eines mit `ssh-keygen` oder einem ähnlichen Befehl auf deinem Admin-Computer.
Wenn du bereits ein Schlüsselpaar hast, verwende dieses.
Kopiere den öffentlichen Schlüssel mit `ssh-copy-id` oder einem ähnlichen Tool auf den Server.
Zum Beispiel:

.install SSH key on server (🏠 Admincomputer)
[source%unbreakable#install-ssh-pubkey,text]
----
$ ssh-copy-id mario_server
/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
/usr/bin/ssh-copy-id: INFO: 2 key(s) remain to be installed -- if you are prompted now it is to install the new keys
mario2024@mario_server's password:

Number of key(s) added: 2

Now try logging into the machine, with:   "ssh 'mario_server'"
and check to make sure that only the key(s) you wanted were added.
----

Teste, ob bisher alles funktioniert, indem du `ssh mario_server` ausführst.
Du solltest etwa Folgendes sehen:

.successful SSH to server (🏠 Admincomputer)
[source#successful-ssh-to-server,text]
----
$ ssh mario_server
Welcome to Ubuntu 24.04 LTS (GNU/Linux 6.8.0-31-generic x86_64)

... snip ...

Last login: Fri May  3 16:44:52 2024 from 192.168.1.225
user@server:~$
----

=== Server bereitstellen

Führe `provision.sh` auf deinem ((Admin-Computer)) aus (*nicht* auf deinem Server):

.mario first run (🏠 Admincomputer)
[source%unbreakable#mario-first-run,bash]
----
cd mario/ansible
./provision.sh
----

Beim ersten Aufruf überprüft mario die Voraussetzungen und fordert dich auf, server­spezifische Werte in eine Konfigurationsdatei einzugeben.

.mario first run output (🏠 Admincomputer)
[source%unbreakable#mario-first-output,text]
----
You don't have a config file. I'll create one for you now.

Please edit 'config' and re-run this script.
----

Hier ist eine Anleitung zu den Einstellungen in deiner `config`, die du gegenüber den Standardwerten ändern musst. Lies dir auch unbedingt die Kommentare in dieser Datei durch. Ich gehe davon aus, dass du einen Domainnamen und einen DNS-Anbieter mit API-Zugang hast. Siehe <<Server-Domainname>> für Details, wie du diesen erhältst.

`DNS_API_PROVIDER`::
Trage hier den Namen deines DNS-Anbieters ein (also des Anbieters, bei dem deine DNS-Einträge verwaltet werden).
mario konfiguriert Traefik so, dass es direkt mit deinem DNS-Server kommuniziert, um Let's-Encrypt-Zertifikate auszustellen.
Dein Domain-Registrar (wo du die Domain gekauft hast) ist nur relevant, wenn er auch dein DNS-Anbieter ist.
`NAMECHEAP_*`, `DUCKDNS_*`, `R53_DNS_*`, `DO_*`...::
Trage hier die Zugangsdaten *nur eines* Anbieters ein – und zwar desselben Anbieters, den du in `DNS_API_PROVIDER` angegeben hast.
`DNS_RESOLVER_EMAIL`::
Gib hier eine E-Mail-Adresse an, die zu deinem DNS-API-Anbieter passt.
Unter dieser Adresse wirst du möglicherweise von Let's Encrypt kontaktiert.
`MARIO_DOMAIN_NAME`::
Das ist ein Name wie `beispiel.duckdns.org` oder `beispiel.com`.
Einzelne Dienste werden darauf basierend benannt, z.B. `jellyfin.beispiel.com`.

Beende das Bearbeiten von `config` und führe anschließend `provision.sh` erneut aus.
Dieser Durchlauf fragt dich nach dem Passwort, das du während der <<OS-Installation>> festgelegt hast. Bei weiteren Durchläufen ist das nicht mehr nötig.
Die Ausgabe sollte in etwa so aussehen:

.mario second run output (🏠 Admincomputer)
[source#mario-second-run,text]
----
BECOME password:

PLAY [all] *********************************************************************

TASK [base : Configure apt cache] **********************************************
ok: [mario_server]

TASK [base : Install packages] *************************************************
changed: [mario_server]

... snip ...

PLAY RECAP *********************************************************************
mario_server               : ok=21   changed=0    unreachable=0    failed=0    skipped=3    rescued=0    ignored=0
----

Bei mir dauert der Vorgang ungefähr zehn Sekunden.
Im **Recap** werden bei einem vollständig eingerichteten System alle Aufgaben als `ok` angezeigt.
Einige Aufgaben werden mit `skipped` übersprungen, bis Nextcloud zum ersten Mal gestartet wurde – das kannst du vorerst ignorieren.

Wenn `provision.sh` ohne Fehler abgeschlossen wurde, konnte mario deinen Server und die Dienste erfolgreich einrichten.
Fahre direkt fort mit <<Dienste starten>>.

=== Server-Domainname

(((DNS)))
Dein Server braucht einen Namen.
Du erhältst einen Domainnamen von einem Registrar und gibst diesen Hostnamen während der <<OS-Installation>> ein.
Ich empfehle, einen einzigen Domainnamen zu verwenden und alle Dienste über Subdomains zu benennen (z.B. `cloud.example.com`).
Du kannst entweder einen kostenlosen Domainnamen verwenden oder einen bei einem Registrar kaufen.
mario benötigt den Domainnamen, um einen DNS-Anbieter mit API zur Einrichtung der HTTPS-Verschlüsselung für den Webverkehr verwenden zu können.
Beachte, dass sich Registrar und DNS-Anbieter unterscheiden können.

Du möchtest deinen Server vielleicht auch von unterwegs per Namen erreichen können, falls du WAN-Zugriff erlaubst und/oder eine dynamische WAN-IP-Adresse hast.
Frage bei deinem DNS-Anbieter nach, wie du entsprechende Einträge (z.B. `A`- und `CNAME`-Einträge) hinzufügen kannst.

==== Öffentlicher DNS

Duck DNS bietet einen kostenlosen Domainnamen- und DNS-Dienst an.
mario funktioniert auch mit kostenpflichtigen Diensten wie Namecheap, DigitalOcean und Route 53.
Ich empfehle eine der kostenpflichtigen Optionen gegenüber Duck DNS.
Die Unterstützung weiterer DNS-Anbieter (hust, insbesondere selbstgehosteter!) könnte später hinzugefügt werden.

NOTE: Öffentliche DNS-Einträge setzen keinen WAN-Zugriff voraus.
<<Digitale Sicherheit>> behandelt den WAN-Zugriff im Detail.

===== Duck DNS

Wenn du einen kostenlosen Domainnamen von einem Anbieter mit API möchtest, kannst du dein Glück mit Duck DNS versuchen.

. Starte auf [https://duckdns.org](https://duckdns.org).
. Melde dich an und füge eine Domain hinzu.

Deine Domain wird etwa so heißen: `blah.duckdns.org`.
Verwende dies anstelle von `example.com`, wo es passt – z.B. `cloud.blah.duckdns.org` anstelle von `cloud.example.com`.

===== Amazon Route 53

Wenn du dich für Route 53 entscheidest, erstelle eine neue „Hosted Zone“ mit dem Domainnamen, den du besitzt.
Notiere dir die Route 53-Nameserver.
Gehe zurück zu deinem Domain-Registrar und trage dort diese Nameserver ein.

Erstelle bei Amazon IAM einen Benutzer mit der Berechtigung, diese Hosted Zone zu aktualisieren.
Hier ist eine Richtlinie mit viel zu vielen Rechten, die aber dennoch funktioniert:

.naive Route 53 policy
[source%unbreakable#naive-r53-policy,json]
----
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": "route53:*",
      "Resource": "*"
    }
  ]
}
----

==== Dynamisches DNS

Wenn du WAN-Zugriff möchtest und sich deine IP-Adresse regelmäßig ändert, ist es praktisch, diese automatisch in den DNS-Einträgen zu aktualisieren.
Ähnlich wie Traefik HTTPS-Zertifikate einrichtet, nutzt auch dieser Vorgang eine API deines DNS-Anbieters.
Es gibt verschiedene Möglichkeiten – alle als Übungen für die Leserin oder den Leser gedacht:
Eine Möglichkeit ist, einen dynamischen DNS-Client in einem Docker-Container bereitzustellen.
Solche Dienste sind in der Regel sehr einfach einzurichten.
Eine andere Idee ist, zu prüfen, ob dein Router dynamische DNS-Updates direkt durchführen kann.

==== Interner DNS

Es ist praktisch, einen internen DNS-Server zu haben, um deinen Server per Namen ansprechen zu können.
Diese internen Namen sollten den öffentlichen Namen entsprechen und auf ausschließlich im LAN erreichbare, private IP-Adressen zeigen.
So kannst du innerhalb und außerhalb deines LAN dieselben Namen verwenden – und deine Let's-Encrypt-Zertifikate funktionieren weiterhin.
Dein LAN-Router hat wahrscheinlich einen integrierten DNS-Server und erlaubt dir möglicherweise, IP-Adressen Namen zuzuweisen.

Falls du keinen internen DNS-Server hast, kannst du weitere Hostnamen-zu-IP-Adressen-Zuordnungen anlegen – so wie bereits im Abschnitt <<SSH Setup>> gezeigt.
Hier ist noch einmal die `hosts`-Datei:

// Das könnte auch eine einzelne Zeile mit einer IP-Adresse und mehreren Hostnamen sein.

.hosts file with service names (🏠 Admincomputer)
[source%unbreakable#hosts-file-with-service-names,text]
----
# for provisioning from Admincomputer
192.168.1.100	mario_server

# for accessing services from Admincomputer
192.168.1.100	traefik.example.com
192.168.1.100	cloud.example.com
192.168.1.100	jellyfin.example.com
192.168.1.100	wallabag.example.com
192.168.1.100	scratch.example.com
----

Das manuelle Zuordnen von IP-Adressen zu Hostnamen mit einer Hosts-Datei ist hilfreich für die erste Einrichtung und Wartung, wenn dein interner DNS-Server ausfällt.
Denk daran, dass nur der Computer mit diesen spezifischen Zuordnungen die Namen verwenden kann.
Teste die Zuordnungen mit `ping` auf deinem Admin-Computer.

TIP: Ich habe Beispiele für zwei Arten von Dienst-Domänennamen gezeigt.
`cloud.example.com` gibt die Funktion des Dienstes an, nicht den Markennamen des Dienstes.
`nextcloud.example.com` würde genauso gut funktionieren.
Die Wahl liegt bei dir.

=== Dienste starten

mario hat deinen Server so vorbereitet, dass er eine Handvoll Dienste ausführen kann.
Docker und Docker Compose sind installiert.
Docker-Konfigurationsdateien befinden sich in Verzeichnissen unter `/root/ops`.
Daten für Dienste befinden sich in Verzeichnissen unter `/data`.

Keiner der Dienste läuft bisher.
Gleich werden wir sehen, wie man sie einschaltet und benutzt.

Zuerst nehmen wir einen kleinen Schritt, um uns viel Tipperei zu ersparen.
Dienste werden mit Docker Compose gestartet und gestoppt, das immer mit `docker compose` aufgerufen wird.
Wenn du `docker compose` ausführst, musst du dich zuerst in einem Ordner befinden, der eine Datei `compose.yml` enthält.
Der Name dieses Ordners entspricht üblicherweise dem Namen des Dienstes.
Ein typisches Nutzungsmuster sieht so aus:

.start a service in its folder (🚀 server)
[source%unbreakable#start-service-in-folder,bash]
----
sudo su -
cd /root/ops/traefik
docker compose up -d
----

Versuchen Sie, diese Methode zu vermeiden.
Je weniger Befehle Sie direkt als `root` ausführen, desto besser.
Ich empfehle stattdessen Folgendes:

.start a service, explicit configuration file (🚀 server)
[source#start-service-explicit-config,bash]
----
sudo docker compose --file /root/ops/traefik/compose.yml up -d
----

mario installs a program called `dc` on the server to save you some typing:

.start a service with dc (🚀 server)
[source%unbreakable#start-service-with-dc,bash]
----
# equivalent to
# sudo docker compose --file /root/ops/traefik/compose.yml up -d
dc traefik up -d
----

TIP: Für einige Befehle, darunter `docker compose`, ist `sudo` erforderlich.
Das Skript `dc` führt `sudo` automatisch für Sie aus.

==== Reverse-Proxy starten

(((Traefik)))
Richten Sie zuerst den ((Reverse-Proxy)) ein.
Starten Sie auf Ihrem Server Traefik mit `dc traefik up -d`.
Wenn das funktioniert hat, warten Sie ein bis zwei Minuten und besuchen Sie `\https://traefik.example.com` in einem Webbrowser, um das Traefik-Dashboard zu sehen.
Während Sie auf das Dashboard warten, können Sie die Logs mit `dc traefik logs -f` mitverfolgen.

Es kann ein bis zwei Minuten dauern, bis Traefik die Let's Encrypt-Zertifikate für die HTTPS-Verschlüsselung eingerichtet hat, also machen Sie sich keine Sorgen, wenn Sie anfangs Warnungen über ungültige Zertifikate sehen.
Für einen funktionierenden Traefik-Dienst sollte in etwa Folgendes erscheinen:

// Das waren ziemlich lange Zeilen.
// Ich habe den Servicenamen gekürzt, das Datum und "INF" (Info-Loglevel) entfernt und `https://acme-v02.api.letsencrypt.org/directory` durch eine Ellipse ersetzt.
// Außerdem habe ich diese Zeilen weggelassen:
//
// reverse-proxy-1  | 2024-05-04T10:03:01Z INF
// reverse-proxy-1  | Stats collection is disabled.
// reverse-proxy-1  | Help us improve Traefik by turning this feature on :)
// reverse-proxy-1  | More details on: https://doc.traefik.io/traefik/contributing/data-collection/
// reverse-proxy-1  |

.typical Traefik logs, edited for brevity (🚀 server)
[source#typical-traefik-logs,text]
----
+ sudo docker compose --file /root/ops/traefik/compose.yml logs -f
rp-1 | Traefik version 3.0.0 built on 2024-04-29T14:25:59Z version=3.0.0
rp-1 | Starting provider aggregator aggregator.ProviderAggregator
rp-1 | Starting provider *traefik.Provider
rp-1 | Starting provider *docker.Provider
rp-1 | Starting provider *acme.ChallengeTLSALPN
rp-1 | Starting provider *acme.Provider
rp-1 | Testing certificate renew... acmeCA=... providerName=myresolver.acme
^Ccanceled
----

Wenn du eine Weile gewartet, die Seite neu geladen hast und dein Browser immer noch ungültige Zertifikatswarnungen zeigt, wenn du versuchst, `https://traefik.example.com` zu besuchen, lies die Traefik-Logmeldungen sorgfältig durch und sieh dir auch <<Verschlüsselungszertifikate>> für Schritte zur Fehlerbehebung an.
Sobald du das Dashboard sehen kannst, beende das Verfolgen der Traefik-Logs mit kbd:\[Strg+c].

==== Andere Dienste starten

Das Starten eines mario-Dienstes erfolgt immer mit dc SERVICE up -d, genau wie wir es mit Traefik gemacht haben.
Um alles auf einmal hochzufahren, kannst du dieses Shell-Skript verwenden:

.start all services ad-hoc Bash script (🚀 server)
[source%unbreakable#start-other-services,bash]
----
for service in $(sudo ls /root/ops); do
    dc $service up -d
done
----

Dies wird auch Images abrufen und erstellen sowie Container bei Bedarf aktualisieren.
Dienste, die nicht mit ihrer compose.yml-Datei übereinstimmen, werden neu gestartet.
Dies ist idempotent: Bereits laufende und aktuelle Dienste bleiben unverändert.

=== Verschlüsselungszertifikate

(((HTTPS)))
(((encryption, HTTPS)))
Traefik installiert automatisch ((Let's Encrypt))–((Zertifikate)), um den HTTP-Datenverkehr zu verschlüsseln.
Die Zertifikate werden über eine DNS-Challenge ausgestellt.
Diese Methode zur Authentifizierung einer Zertifikatsanfrage ist besonders praktisch für Server ohne öffentlich erreichbare eingehende Ports und ermöglicht so bequemes HTTPS selbst in geschlossenen LANs.
Die DNS-Challenge wird über Labels in der compose.yml-Konfigurationsdatei von Traefik eingerichtet.

(((SSL termination)))
Traefik kann HTTPS-Verbindungen annehmen, entschlüsseln und als unverschlüsseltes HTTP an Webdienste weiterleiten.
Dies nennt man *SSL-Termination* und wird in Traefiks `compose.yml` über Zeilen mit `acme` konfiguriert.

Schau dir einmal die `compose.yml`-Datei eines beliebigen mit mario gelieferten Dienstes an.
Jeder Dienst hat im Router-Abschnitt eine `tls`-Sektion definiert, um HTTPS-Verschlüsselung und SSL-Terminierung zu aktivieren.

Falls beim Aufruf deiner Webdienste Zertifikatswarnungen erscheinen, prüfe zuerst die Traefik-Logs wie in <<Reverse-Proxy starten>> beschrieben.
Um die Protokollausgabe von Traefik zu erweitern, ändere in der `compose.yml` von Traefik den Eintrag
`--log.level=INFO` zu `--log.level=DEBUG`, führe die Provisionierung erneut aus und starte Traefik neu.
Falls das Problem weiterhin besteht, überprüfe, ob DNS-Abfragen erfolgreich sind, da dies die DNS-Challenge beeinflusst.

.example DNS tests
[source#example-dns-tests,bash]
----
####
# Try these commands on both the Admincomputer and server.
# Replace dig (and its arguments) with your favorite DNS tool.
# Replace traefik.example.com with your Traefik service name.
####

# Look up Traefik on default DNS server.
# Should quickly return a LAN private IP address.
dig traefik.example.com

# Look up Traefik server name on Quad9 DNS.
# - @9.9.9.9 forces Quad9's DNS service.
# - +short uses terse output
# Should return nothing--we didn't set an IP address.
dig @9.9.9.9 +short traefik.example.com

# Fetch TXT record for Traefik.
# Contains a long unique string while Traefik is executing a
# DNS challenge and is otherwise not set.
dig traefik.example.com TXT
----

=== Kleiner Testdienst

Falls du bis hierher gekommen bist, probiere, einen Testdienst zu starten.
Das ist nützlich, um zu bestätigen, dass das Netzwerk für Docker-Container auf deinem Host korrekt funktioniert.
Wenn Traefik bereits läuft, haben wir diese Bestätigung eigentlich schon (weil Traefik für die DNS-Challenge Netzwerkzugriff benötigt),
aber es kann trotzdem ein praktisches Werkzeug für später sein – oder zumindest ein positiver Schritt in Richtung eigener nützlicher Dienste.

Dieser Testdienst demonstriert das Pingen eines öffentlichen Servers.
Erstelle _auf deinem_ Server den Ordner: `~/ping/`.
Lege in diesem Ordner eine Datei `compose.yml` mit folgendem Inhalt an:

.tiny test service config (🚀 server)
[source%unbreakable#tiny-test-service-config,yaml]
----
version: '3'

services:
  test:
    image: alpine
    command: ping example.com
----

Im Ordner `~/ping/` führe Befehl `sudo docker compose up` aus.
Drücke nach ein paar Sekunden kbd:[Strg+C].
Du solltest dann ungefähr so etwas sehen:

.start tiny test service (🚀 server)
[source%unbreakable#start-tiny-test-service,text]
-----
$ cd ~/ping/
$ sudo docker compose up
[+] Running 2/2
 ✔ Network ping_default   Created                                      0.1s
 ✔ Container ping-test-1  Created                                      0.1s

Attaching to ping-test-1
ping-test-1  | PING example.com (93.184.216.34): 56 data bytes
ping-test-1  | 64 bytes from 93.184.216.34: seq=0 ttl=55 time=3.477 ms
ping-test-1  | 64 bytes from 93.184.216.34: seq=1 ttl=55 time=3.236 ms
ping-test-1  | 64 bytes from 93.184.216.34: seq=2 ttl=55 time=3.363 ms
^CGracefully stopping... (press Ctrl+C again to force)
Aborting on container exit...
[+] Stopping 1/1
 ✔ Container ping-test-1  Stopped                                     10.4s
canceled
-----

[%unbreakable]
TIP: Für Bonuspunkte kannst du deinen kleinen Testdienst in mario integrieren.

Das ist auch die Grundlage, um später spannendere Dienste hinzuzufügen.
Nur ein paar zusätzliche Zeilen Code und Konfiguration reichen, um einen kleinen ((API))- oder Webdienst zu erstellen – und mit ein paar weiteren Zeilen kannst du ihn über deinen Reverse-Proxy veröffentlichen.

== Dienste

Jetzt kannst du die von mario bereitgestellten Dienste ausprobieren.
Dieses Kapitel behandelt, was sie bieten und wie du sie verwaltest.

[#purposes-of-default-mario-services]
.Verwendungszwecke der standardmäßigen mario-Dienste
|===
|Verwendungszweck |Siehe

|Dateien synchronisieren und freigeben, Groupware |<<Nextcloud: Dateisynchronisation und -Freigabe>>
|Musik und Heimvideos streamen |<<Jellyfin: Audio- und Videostreaming>>
|Artikel offline und ohne Ablenkung lesen |<<Wallabag: Artikel speichern und lesen>>
|Andere Dienste auf dem neuesten Stand halten |<<Watchtower: Dienst-Updates>>
|Programmieren mit visuellen Werkzeugen lernen |<<Scratch: visuelle Programmierung>>
|===

Diese speziellen Dienste sind nur ein kleiner Bruchteil derjenigen, die für das Self-Hosting verfügbar sind.
Sie spiegeln die Vorlieben meiner Nutzerinnen wider (einschließlich – und überproportional – meiner eigenen) in den Bereichen Lesen, Teilen, Medien usw.
Wenn Sie diese Dienste zum Laufen bringen, bieten sie Ihren Nutzerinnen bereits nützliche Funktionen und dienen als guter Ausgangspunkt, um alles Mögliche selbst zu hosten.

Zu jedem Dienst finden Sie meine persönlichen Kommentare und Probleme, auf die ich gestoßen bin.
Falls ich eine Funktion erwähne, die ich gern hinzugefügt sehen würde, habe ich auch schon darüber nachgedacht, sie selbst zu implementieren (oder jemanden davon zu überzeugen, sie hinzuzufügen, oder Geld zu sammeln, um jemanden für die Umsetzung zu bezahlen).
Wenn ich auf einen geschlossenen Bug im Issue-Tracker verweise, liegt das daran, dass ich den Fehler getestet habe und er – zum Zeitpunkt des Schreibens – in einer offiziellen bzw. unterstützten Version, die angeblich die Korrektur enthält, weiterhin auftritt.

Die mobile Nutzung ist bei den von mir betreuten Nutzer*innen hoch, daher war dies ebenfalls ein Auswahlkriterium.
Nextcloud, Jellyfin und Wallabag verfügen über mobile Apps und Integrationen, die ich häufig verwende.

Die serverseitigen Befehle zur Verwaltung von Diensten sind standardisiert: Sie werden das Muster dc: SERVICE ACTION ARGS immer wieder sehen.

// this forced page break was originally just to improve the print PDF layout, but I find it doesn't hurt the screen PDF layout so I don't use an ifdef::shb-printPDF[]

<<<

=== Nextcloud: Dateisynchronisation und -Freigabe

(((Nextcloud)))
Eine Steadfast Personal Cloud benötigt bequeme Dateifreigabe und Synchronisierung.
Nextcloud ist aufgrund seiner Stabilität und Popularität eine ausgezeichnete Wahl.
Das Selbst-Hosting kann entmutigend wirken, aber mario macht es einfach und sogar spaßig.

[#image-screenshot-nextcloud]
.Nextcloud Files-App-Screenshot mit Dateien, Ordnern und Teilen-Schaltflächen.
image::nextcloud.png[align="center",scaledwidth=80%]

Ein gut gepflegter Nextcloud-Server bietet eine solide Grundlage für das „De-Googlen“.
Nextcloud kann kostenlos selbst gehostet werden, wenn es über mario installiert wird.
Sobald Sie Nextcloud zum Laufen gebracht haben, finden Sie unter <<Mehr über Nextcloud>> viele meiner Gedanken darüber, wie man es am besten anpasst.

[#nextcloud_quick_start]
==== Schnellstart

. Provisionieren Sie mit mario von Ihrem Admin-Computer.
. Starten Sie Nextcloud mit `dc nextcloud up -d` auf Ihrem Server.
. Rufen Sie `\https://cloud.example.com` auf Ihrem Admin-Computer auf.
. Folgen Sie der webbasierten Setup-Seite, um ein Admin-Konto zu erstellen.
. Überspringen Sie die Installation der empfohlenen Apps.

==== MWartungshinweise

Führen Sie `dc nextcloud pull && dc nextcloud up -d` auf Ihrem Server aus, um die Nextcloud-Service-Container zu aktualisieren und zu ersetzen.

==== Probleme

Siehe <<Verschiedene Probleme>>.

<<<

=== Jellyfin: Audio- und Videostreaming

(((Jellyfin)))
https://jellyfin.org[Jellyfin] ist ein persönlicher Streaming-Medienserver.
mario richtet einen grundlegenden Jellyfin-Server ein.

[#image-screenshot-jellyfin]
.Jellyfin-Screenshot mit Metadaten zu einem Film. Big Buck Bunny ist unter der Lizenz CC BY-3.0 von der Blender Foundation veröffentlicht.
image::jellyfin.png[align="center",scaledwidth=80%]

==== Schnellstart

. Provisioniere mit mario vom Admin-Computer aus.
. Starte Jellyfin mit `dc jellyfin up -d` auf dem Server.
. Navigieren zu `\https://jellyfin.example.com` auf dem Admin-Computer.
. Folgen den webbasierten Einrichtungsschritten.

(((Jellyfin, using a GPU with)))
Wenn Sie über eine GPU verfügen, sollten Sie sich die https://jellyfin.org/docs/general/administration/hardware-acceleration/[Hardwarebeschleunigung ansehen].
Diese ist nützlich, wenn Videos nicht direkt von einem Client abgespielt werden können und daher on the fly transkodiert werden müssen.
Jellyfin kann zwar auch nur mit der CPU transkodieren, mit einer GPU geht es jedoch deutlich schneller.

[%unbreakable]
TIP: Jellyfin kann auch bestimmte CPUs mit integrierter Hardware-Transkodierung nutzen,
zum Beispiel Intel Quick Sync Video.

==== Wartungshinweise

Führen Sie `dc jellyfin pull && dc jellyfin up -d` auf Ihrem Server aus, um den Jellyfin-Dienstcontainer zu aktualisieren und zu ersetzen.

==== Probleme

Hier sind einige Funktionen, die ich gerne in Jellyfin implementiert sehen würde.

===== Funktion: Geteilte Playlists

https://github.com/jellyfin/jellyfin/issues/6264#issuecomment-1338518980[Playlists sind automatisch privat].
https://features.jellyfin.org/posts/173/share-playlists[Ich mag die Möglichkeit sie zu teilen].

===== Funktion: Clips

Ich möchte oft einen bestimmten Teil eines Mediums teilen, anhören oder erneut ansehen.
Es wäre großartig, wenn man https://features.jellyfin.org/posts/1036/bookmark-audio-video-segments[Clips] erstellen könnte, ohne tatsächlich neue Mediendateien erstellen zu müssen.

===== Funktion: Offline Medien mobil schauen

Ich möchte eine Jellyfin-Mobile-App, die Medien automatisch zwischenspeichert und https://features.jellyfin.org/posts/218/support-offline-mode-on-android-mobile[Offline-Wiedergabe ermöglicht].

Workaround: Es gibt zwei separate Mobile-Apps, die Medien für die Offline-Wiedergabe herunterladen und zwischenspeichern können https://github.com/jmshrv/finamp[Finamp] für Musik und https://github.com/jarnedemeulemeester/findroid[Findroid]für Videos

==== Jellyfin-Medien mit Nextcloud verwalten

Jellyfin und Nextcloud laufen beide auf demselben Server.
Du kannst diese Tatsache nutzen, um ihre individuellen Stärken als Dienste zu kombinieren, während sie auf denselben Daten arbeiten, der eine als Media-Streamer und der andere als Medien-Dateimanager.
mario erstellt spezielle Musik- und Videoordner auf dem Server und stellt sie beiden Diensten zur Verfügung.
Nextclouds „External Storages“ ermöglicht es dir, Dateien in diese Ordner hochzuladen, und Jellyfin wird die hochgeladenen Dateien automatisch erkennen und das Streamen ermöglichen.

Nextclouds `compose.yml`-Datei hat den Eintrag `/data/shared/media/video:/data/video:rw` in volumes.
`/data/shared/media/video` ist der Pfad auf dem Server, der die eigentlichen Videodateien enthält, `/data/video` ist der Ort, an dem sie im Container erscheinen, und `rw` bedeutet, dass Nextcloud Lese- und Schreibzugriff auf dieses Volume hat.
Es gibt einen weiteren ähnlichen Ordner für Musikdateien.
Siehe <<Detailed setup>>, um zu erfahren, wie man sie in Nextcloud als „External Storages“ hinzufügt.

In Jellyfins `compose.yml`-Datei findest du ähnliche Zeilen zum Hinzufügen von Musik- und Video-Volumes, aber mit `ro` (für Read-Only) statt `rw`.
Jellyfin benötigt nur Lesezugriff auf die Ordner, um die darin enthaltenen Dateien streamen zu können.

Um die von Nextcloud verwalteten Mediendateien in Jellyfin anzuzeigen, füge zwei Medienbibliotheken hinzu:

Wähle den Inhaltstyp „Movies“, klicke auf das „+“-Symbol neben „Folders“ und wähle `/data/video`.

Wähle den Inhaltstyp „Music“, klicke auf das „+“-Symbol neben „Folders“ und wähle `/data/music`.

<<<

=== Wallabag: Artikel speichern und lesen

(((Wallabag)))
https://wallabag.org[Wallabag] speichert Artikel für offline Lesen ohne Ablenkungen. 

[#image-screenshot-wallabag]
.Wallabag screenshot der ungelesene Artikel in der Sammlung zeigt.
image::wallabag.png[align="center",scaledwidth=80%]

==== Schnellstart

. Mit mario von deinem Admincomputer bereitstellen.
. Starte Wallabag mit `dc wallabag up -d` auf deinem Server.
. Gehe auf `\https://wallabag.example.com` auf deinem Admincomputer.
. Melde dich als Benutzer wallabag mit dem Passwort wallabag an.
. Aktualisiere das Passwort für den Benutzer wallabag.

==== Wartungshinweise

Führe auf deinem Server `dc wallabag pull && dc wallabag up -d` aus, um die Wallabag-Dienstcontainer zu aktualisieren und zu ersetzen.
Wenn Probleme auftreten, versuche, Datenbank-Upgrades manuell anzuwenden (siehe <<Bug: Upgrades machen alles kaputt>>).

==== Probleme

Hier ist ein Problem, das ich mit Wallabag habe, und eine Funktion, die ich mir wünsche.

===== Bug: Upgrades machen alles kaputt

https://github.com/wallabag/wallabag/issues/6649[Datenbankmigrationen werden nicht (immer?) automatisch angewandt].
Es könnte noch andere doppelte oder verwandte Bugberichte für dasselbe Problem geben, das ist nur ein Beispiel.
Zum Glück kann man https://github.com/wallabag/docker#upgrading[das Problem einfach umgehen].

Wenden die Problemumgehung in einem mario system wie folgt an:

.force Wallabag database migration (🚀 server)
[source%unbreakable#force-wallabage-db-migration,bash]
----
dc wallabag exec app /var/www/wallabag/bin/console \
  doctrine:migrations:migrate --env=prod --no-interaction
----

Der Befehl `exec` bedeutet, dass wir etwas in einem Container ausführen wollen.
Dies führt das Dienstprogramm `console` im app-Service-Container aus.
Die zweite Zeile gibt an, dass notwendige Datenbankmigrationen (Schema- und Datenaktualisierungen) mit den `prod`-Einstellungen ohne interaktive Eingabeaufforderungen ausgeführt werden sollen.

Dies ist idempotent, wie Datenbankmigrationen sein sollten.
Nach dem ersten Durchlauf geben nachfolgende Durchläufe aus: [OK] Already at the latest version.

Es ist unklar, warum diese Migration nicht automatisch während eines Upgrades durchgeführt wird.
Vielleicht ist sie nur in speziellen Fällen notwendig – ich musste sie in den letzten Jahren nur zweimal ausführen.

===== Funktion: Inhalte mit anderen Nutzern teilen

I möchte die Möglichkeit haben, https://github.com/wallabag/wallabag/issues/679[Inhalte mit anderen Wallabag Nutzern in Rahmen des Wallabag programs zu teilen].

<<<

=== Watchtower: Dienst-Updates

((Watchtower)) ist praktisch, um Ihre Docker-Container auf dem neuesten Stand zu halten.
Es erkennt und überprüft veraltete Container, lädt neue Images herunter und startet Dienste neu, um neue Container zu erstellen.

// Quelle: https://containrrr.dev/watchtower/images/logo-450px.png
// Erscheint an: https://containrrr.dev/watchtower/
// Die Lizenz der anderen watchtower teile ist Apache 2.0
// Dieses logo hat keinen Lizenztext.
// Dieses Logo-Bild besteht nur aus einfachen geometrischen Formen oder Text. Es erreicht nicht die nötige Schöpfungshöhe für einen urheberrechtlichen Schutz und ist daher gemeinfrei.
// Siehe https://commons.wikimedia.org/wiki/Commons:Threshold_of_originality
// und https://en.wikipedia.org/wiki/Public_domain

image::watchtower.png[align="center",scaledwidth=40%]

Wenn du niemals möchtest, dass Container automatisch aktualisiert werden, führe Watchtower nicht aus.
Oder verwende die https://containrrr.dev/watchtower/arguments/[Konfigurationseinstellungen], um automatische Updates für bestimmte Container zu erlauben oder zu blockieren.
mario verwendet zum Beispiel ein Container-Label, um zu verhindern, dass Watchtower Scratch aktualisiert.

==== Schnellstart

. Provisioniere mit mario vom Admincomputer.
. Starte Watchtower mit `dc watchtower up -d` von deinem server.

From now on it'll run in the background, automatically upgrading containers whenever possible, on a reasonable schedule (every 24 hours by default).
You can forget about it until it breaks (or breaks something else).

==== Wartungshinweise

Führe auf deinem Server `dc watchtower pull && dc watchtower up -d` aus, um den Watchtower-Service-Container zu aktualisieren und zu ersetzen.

==== Probleme

Es https://github.com/containrrr/watchtower/issues/90[führt kein automatisches Rollback durch, wenn ein Container-Upgrade fehlschlägt].
Zugegeben, das wäre schwierig umzusetzen.
Ein Dienst könnte zum Beispiel nur unidirektionale Datenbankmigrationen haben.
Ich denke, die Watchtower-Maintainer haben die richtige Entscheidung getroffen, automatische Rollbacks wegzulassen (wahrscheinlich, um Watchtower einfach zu halten).

Es kann passieren, dass ein Dienst durch Watchtower beschädigt wird.
Wenn du den Verdacht hast und weißt, wann der Dienst kaputtging, versuche dies mit den Upgrades in `dc watchtower logs` zu korrelieren.
Ich vermeide das, indem ich Watchtower nur für nicht-kritische Dienste nutze.
Zum Beispiel lasse ich Watchtower meinen Nextcloud-Dienst nicht automatisch upgraden.

<<<

=== Scratch: visuelle Programmierung

((Scratch)) ist eine beliebte und sehr zugängliche visuelle Programmiersprache, die auf interaktive Multimedia-Anwendungen und Lernen ausgelegt ist.
Die bekannteste https://scratch.mit.edu[öffentliche Online-Version] bietet Teilen, Studios, Kommentare, Sterne, Herzen, endlose Memes und Spiele.
Diese „sozialen“ Funktionen können genau das sein, was ein Nutzer will/benötigt (z.B. ein bestehendes Projekt remixen und daraus lernen), oder sie können einen Nutzer unbeabsichtigt von produktiver Erstellung hin zu gedankenlosem Konsum umleiten (z.B. Doomscrolling).

Hier kommt deine neue Steadfast-Macht ins Spiel: Scratch kann selbst gehostet werden, ohne die sozialen Funktionen.
Tatsächlich ist das die einfachste Art, es selbst zu hosten.
Dies ist eine großartige Option, wenn deine Nutzer sich auf das Erstellen in Scratch konzentrieren und persönlich sozial interagieren möchten. 😉

[#image-screenshot-scratch]
.Scratch Screenshot eines neuen Projektes.
image::scratch.png[align="center",scaledwidth=80%]

Scratch benötigt keine persistenten Daten, keine Einrichtung und keine Authentifizierung.

==== Schnellstart

. Mit mario vom Admincomputer bereitstellen.
. Scratch auf deinem Server mit `dc scratch up -d` starten.
. Auf deinem Admincomputer zu `\https://scratch.example.com` navigieren.

==== Wartungshinweise

Scratch verwendet ein benutzerdefiniertes Docker-Image, daher ist der Upgrade-Prozess deutlich komplexer als bei anderen Diensten.
Öffne zunächst das Scratch-`custom/Dockerfile` auf deinem Admincomputer.
Dieses `Dockerfile` befindet sich in einem Unterordner von `mario/ansible` im mario-Quellcode.

Wenn du das Image auf einer neueren Version von Node.js basieren lassen willst, besuche die https://hub.docker.com/_/node[Node.js-Seite auf Docker Hub] und wähle eine Version für die `FROM`-Zeile im `Dockerfile`.
Wenn du Scratch aktualisieren möchtest, besuche die https://github.com/scratchfoundation/scratch-gui/releases[Releases-Seite] und wähle eine Version für `SCRATCH_VERSION` im `Dockerfile`.

Führe `provision.sh` erneut auf dem Admincomputer aus.
Baue das Image auf dem Server mit `dc scratch build --pull` neu.
Schließlich ersetze den Scratch-Dienstcontainer, indem du `dc scratch up -d` auf dem Server ausführst.

// FIXME: when "What's next?" is translated here, the reference <<_whats_next>> elsewhere in the book must also be updated.

== What's next?

By this point, I'm assuming you've got your server running and some services too.
Here's where you can find a handful of ideas for what to try next.

=== Learn more

If you like this book, and you want to learn and do more, do it.
Ride that wave of inspiration.
Seek both breadth and depth.

For breadth, look for a comprehensive book about Linux since mario expects Linux, and a better understanding of Linux can help you customize your server with confidence.
There aren't any Ubuntu-specific dependencies, but Ubuntu is the only Linux flavor mario has been extensively tested on at the time of writing.
One of my first purchases when I wanted to just finally „get“ Linux was _UNIX: The Complete Reference_, a thousand-page monster covering many, many concepts.
I studied it in chunks, referred to it often, and never read it cover to cover.
If I started learning again from scratch today, I'd still have a book like that handy while studying online resources and trying stuff at home.

For depth, immerse yourself in fundamentals.
Learn how a computer works.
Push past abstractions and make progress towards first principles.
Take a computer science class in an area supporting something else you want to do.
For example, if you want to code your own web services, take a class in programming for the web.
If you want to understand how Quellcode makes a computer do things, take a class in compilers.

Work through this book in a class or small group.
See <<Discussion topics>> and <<Übungen>>.

Participate in ((FOSS)) communities to learn from and share with others.
Pass on what you've learned.
File a bug.
Post in a forum.
It's fun!

(((SeaGL)))
Conferences like https://seagl.org[SeaGL] bring together bright minds on many topics, including self-hosting.
If you've done something cool, share it!

=== Use a GPU

(((GPU)))
A GPU offers more efficient video transcoding with Jellyfin, reducing server CPU usage and speeding up remote video streaming.

A FOSS voice assistant would benefit from a GPU.

A GPU could also speed up video transcoding and facial recognition.

Modern generative AI workloads like large language model chat and image generation are much faster with a GPU.

=== AI

(((AI)))
AI is once again the latest hotness.
You can run your own image generators and LLMs (large-language models) at home.
No GPU is required.
Here's a `compose.yml` that'll work with mario to stand up https://localai.io[LocalAI].

.example LocalAI service config
[source#example-localai-svc,yaml]
----
version: '3.6'

services:
  api:
    image: quay.io/go-skynet/local-ai:latest
    environment:
      MODELS_PATH: /models
    volumes:
      - /data/localai/models:/models:cached
    command: ["/usr/bin/local-ai" ]
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.localai-https.entrypoints=websecure"
      - "traefik.http.routers.localai-https.rule=Host(`localai.example.com`)"
      - "traefik.http.routers.localai-https.tls.certresolver=myresolver"
      - "traefik.http.routers.localai-https.middlewares=lan-only"
    networks:
      - traefik_default
    restart: unless-stopped
networks:
  traefik_default:
    external: true
----

Note the middleware to only allow traffic from your LAN.
This assumes your LAN uses 192.168.1.* addresses, and expects a corresponding label on the Traefik container to set up the ((middleware)), for example:

.label from Traefik configuration allowing only LAN access
[source#lan-only-traefik-conf-line,yaml]
----
"traefik.http.middlewares.lan-only.ipallowlist.sourcerange=192.168.1.0/24"
----

TIP: Use mario to provision your LocalAI service.

See the https://localai.io[LocalAI documentation] for further setup help.
Once you get that running, you can use the https://apps.nextcloud.com/apps/integration_openai[Nextcloud AI integration app] as a convenient frontend.

=== Pi-hole

(((Pi-hole)))
(((DNS)))
Running a https://pi-hole.net[Pi-hole] service in your LAN helps block advertisements, trackers, and bad actors using DNS block lists.

Clients (laptops, phones, etc) on your network use the Pi-hole as their DNS server, generally as part of DHCP (Dynamic Host Configuration Protocol) auto-configuration by your router or Pi-hole itself (if you use Pi-hole as your DHCP server).

The Pi-hole translates domain names to IP addresses.
If a domain name is on a block list, it returns a false IP address such as 0.0.0.0.

The technique is imperfect, yet simple and effective.

My Pi-hole server sits between my router's DNS server and all clients.

ifdef::backend-html5,backend-pdf[]
[#image-DNS-traffic-diagram]
.Pi-hole DNS traffic flow diagram.
image::DNS-traffic-diagram.svg[align="center",scaledwidth=80%]
endif::[]
ifdef::backend-epub3[]
[#image-DNS-traffic-diagram]
.Pi-hole DNS traffic flow diagram.
image::DNS-traffic-diagram.png[,571,651,align="center"]
endif::[]

Queries for domain names not on any block list will be answered directly or sent upstream.
I set up my Pi-hole to pass queries on to my home router, which will then query a DNS server outside my LAN as necessary.

It's easy to block individual domain names or entire lists as you see fit.
I've used this as an „impulse blocker“, helping the kids avoid distractions during remote school.

The Pi-Hole also has a list of local DNS entries.
I add a few domain names to this list for servers inside my LAN.

Note that some clients will by default bypass an auto-configured DNS server such as Pi-hole.
For example, https://support.mozilla.org/kb/firefox-dns-over-https[DNS over HTTPS in Firefox].

=== Single sign-on

(((Single sign-on)))
It would be convenient for users to be able to log in once to get access to all self-hosted services using a common, consistent, and well-designed mechanism (single sign-on), and for sysadmins to be able to manage all users and groups in one place (centralized identity management).

https://goauthentik.io[Authentik] is one service providing this, and appears to have all the features I want (single sign-on, backend user database, integrates with everything I self-host).
I want to try it out and see it running well for a good while before adding it to mario.
Some of the other self-hosting solutions mentioned in <<Alternativen zu mario>> do include FOSS central identity management.

=== Enforce SSH public key auth

Some sysadmins choose to require public key authentication for ((SSH)) logins.
I think https://security.stackexchange.com/q/3887[it's a good idea] but I didn't want to force it on you so I didn't include it in mario.
I'm using this as an opportunity to demonstrate how to extend mario.
Add this Ansible task to `roles/base/tasks/main.yml`:

.enforce SSH public key auth (🏠 Admincomputer)
[source#enforce-ssh-pubkey-auth,yaml]
----
# This does not affect logging in from a console (e.g. directly connected
# keyboard and monitor, or a virtual console).
- name: Disable tunneled clear text passwords
  copy:
    src: pka-only.conf
    dest: /etc/ssh/sshd_config.d/
    owner: root
    group: root
    mode: 0400
  notify:
    - restart sshd
----

Add this to `roles/base/handlers/main.yml`:

.Ansible handler to restart SSH (🏠 Admincomputer)
[source%unbreakable#ansible-ssh-restarter,yaml]
----
- name: restart sshd
  service:
    name: sshd.service
    state: restarted
----

Create `roles/base/files/pka-only.conf` with:

.SSH server config lines (🏠 Admincomputer)
[source%unbreakable#ssh-server-config,text]
----
PasswordAuthentication no
AuthenticationMethods publickey
----

Finally, re-run `provision.sh`.
From now on, your server will require public key authentication for SSH logins.

=== Allow WAN access

mario blocks ((WAN access)) by default.
Read <<Digitale Sicherheit>> to decide if you want this or not.
You may remove this protection by removing the `lan-only` ((middleware)) from the corresponding router's Traefik label.
For example, to allow WAN access to Nextcloud, make this change in Nextcloud's `compose.yml`:

.patch for WAN access to Nextcloud (🏠 Admincomputer)
[source%unbreakable#open-wan-access,diff]
----
- traefik.http.routers.nc-https.middlewares=nc-head,nc-redir,lan-only
+ traefik.http.routers.nc-https.middlewares=nc-head,nc-redir
----

Similarly for Jellyfin, you may delete the whole line referencing the `lan-only` ((middleware)) in Jellyfin's `compose.yml` if you decide to expose that service on your WAN.

=== Mehr über Nextcloud

Nextcloud is a key part of my self-hosting setup.
I wanted to include a lot of additional details without cluttering up <<Dienste>>, so you'll find these extra sections here.

==== Basic install

(((Nextcloud, installing)))
A basic (default, un-customized) Nextcloud install provides remote file storage, organization, and sharing.
It keeps track of actual files and folders stored somewhere (local, remote, cloud, wherever) and tracks additional metadata about those files and folders in a database.
You access it via a web browser and there is a desktop client to sync files locally, similar to Dropbox, Google Drive, and OneDrive.

I've come to _really_ trust file sync with the Nextcloud desktop app.
If I see a check mark on my desktop app, I know everything is properly synchronized with the server.
I am constantly creating and editing content locally and counting on sync to work (usually on my desktop computer), or creating and editing directly in Nextcloud via the web UI.

There are also apps for mobile devices.
I'll come back to mobile later in the following sections.

==== Object storage

Nextcloud is able to use ((object storage)) for primary data storage.
This is an advanced topic left as an exercise to the reader.
I'll assume primary storage on a local HDD set up by mario.

==== Security

(((Nextcloud, security and)))
A basic Nextcloud install appears to have excellent security.
The Quelle is in heavy use and is backed by a solid company with a reputation that depends on their commitment to security.
They make it easy to lock down and vet (it is FOSS after all).
The defaults appear secure.
They follow best practices.
They have a public bounty program and threat model.

==== Detailed setup

To confirm reproducibility of your Nextcloud server, destroy and re-create it (before you use it for real).
After you get it working once, stop it with `dc nextcloud down`.
Destroy all persistent data with `sudo rm -rf /data/nextcloud`.
That _really_ deletes everything.
Re-provision with mario (run `provision.sh` again).
Follow the setup steps again, see <<nextcloud_quick_start>>.

Read the official docs at `/settings/help` or https://docs.nextcloud.com.

Add apps at `/settings/apps`.
See <<Customization>> for tips on how to roll out apps thoughtfully and which ones are worth your time.

Test configuring a mail server and sending an email at `/settings/admin` (Basic settings).

Add users at `/settings/users`.

Check logs for all containers related to Netcloud with `dc nextcloud logs -f`.

Check Nextcloud internal logs at `/settings/admin/logging` in the web UI or `/data/nextcloud/root/data/nextcloud.log` on the server.
These include specific Nextcloud internal server messages and are often more useful to me than the container logs.
If you see a warning about „1 error in the logs since DATE“ (or perhaps a couple) at `/settings/admin/logging`, you can probably ignore it.
These initial logged errors appear to be harmless, possibly a result of some install-time race conditions.
It is still a good idea to review all logged errors.

Review „Security & setup warnings“ at `/settings/admin/overview`.
You can ignore the warning ‟Could not check for JavaScript support. Please check manually if your webserver serves `.mjs` files using the JavaScript MIME type.” if this succeeds on your Admincomputer:

.JavaScript fetch test (🏠 Admincomputer)
[source%unbreakable#js-fetch-admin,bash]
----
curl -I https://cloud.example.com/apps/settings/js/esm-test.mjs
----

The warning is because the Nextcloud `app` container https://github.com/nextcloud/server/issues/42989[fails at a test] to request a JavaScript test file, likely because of a DNS issue.
To fix it, the request must be able to work from within the Nextcloud `app` container.
In other words, this must succeed (return a successful HTTP response code and include the header `content-type: text/javascript`):

.JavaScript fetch test (🚀 server)
[source%unbreakable#js-fetch-server,bash]
----
dc nextcloud exec app \
  curl -I https://cloud.example.com/apps/settings/js/esm-test.mjs
----

Some maintenance requires the `occ` tool (short for „ownCloud command“).
Run it with `dc nextcloud exec --user www-data app php occ`.

Add `/data/video` as an External storage.
Media files uploaded there will automatically appear in Jellyfin.
First, visit `/settings/apps/featured` and install the „External storage support“ app.
Next, visit `/settings/admin/externalstorages` and install the „External storage support“ app.

* Folder name: Video
* External storage: Local
* Authentication: None
* Configuration: `/data/video`
* Set users, previews, sharing, and remaining options as desired.

Add `/data/music` as an External storage, similar to `/data/video`.

==== More maintenance tips

Visit `/settings/admin/overview` periodically to check for system and security issues that may require manual intervention.
Perform any recommended maintenance on that page.
Ignore the Update section, it may disagree with Docker Hub.
Visit `/settings/admin/logging` periodically to review all server-side log messages.

Running `dc nextcloud pull && dc nextcloud up -d` (on the server) will pull the most recent image of https://github.com/nextcloud/docker with the `stable` release tag.
Using this tag will likely be stable enough for you and your users.
`stable` generally corresponds to the version they call _previous_ at https://docs.nextcloud.com/.

You may opt to „pin“ your Nextcloud to a more specific tag such as `27.1.5-apache`.
This gives you the chance to review and test each upgrade.
You can pin a release tag in Nextcloud's `compose.yml` where the image name appears, just trade `stable` for the tag you choose.
All available tags are https://hub.docker.com/_/nextcloud[listed at Docker Hub].

NOTE: Nextcloud's blog posts and marketing materials use different version names than the release versions from Quellecontrol.
„Hub 6“ on the blog refers to versions `27.\_._` in Quellecontrol, „Hub 7“ to `28.\_._`, and so on.

===== Release cadence

(((Nextcloud, release cadence of)))
https://docs.nextcloud.com/server/stable/admin_manual/release_schedule.html[A major release is shipped every four months].
The Nextcloud apps I care about seem to keep up with this pace, but it does feel a bit aggressive to me.
Developers need to modify their apps each time at least slightly, or heavily if breaking API changes occur.
Thankfully the Nextcloud team https://help.nextcloud.com/t/new-process-for-documenting-core-code-changes-that-affect-app-developers/149828/1[carefully documents changes] to ease app maintenance for developers.

As a _Steadfast_ sysadmin, be sure to check your `/settings/admin/overview` page before upgrading Nextcloud to make sure all the apps you use will work with the version you're upgrading to.
You can override an out-of-date app with the „enable untested app“ option under `/settings/apps`.
Sometimes this works.

Since four months seemed to me like a short window for major releases I started a https://help.nextcloud.com/t/major-release-cadence/161685[thread about it].
Review their https://github.com/nextcloud/server/wiki/Maintenance-and-Release-Schedule[Maintenance and Release Schedule] to make sure your current version is still supported.

==== Performance

If you use mario to deploy Nextcloud, you'll start with a nominally performant server suitable for a small handful of users, assuming you have sufficient hardware resources.
mario includes an author-approved selection of the https://docs.nextcloud.com/server/stable/admin_manual/installation/server_tuning.html[recommended server tuning steps].

I've only had one performance issue in the years I've hosted Nextcloud (knock wood!), so I'll mention it here.
I was seeing slow web requests along with https://github.com/nextcloud/server/issues/35311[lots of database activity].
This had me under the hood with MariaDB for a while.
They've since https://github.com/nextcloud/server/pull/33540[fixed the root cause] so it isn't a problem for new installations.

==== Customization

(((Nextcloud, apps for)))
Nextcloud can be used as-is (see <<Basic install>>) or heavily customized.
The simplest and safest way to customize is by installing an app from the built-in app store (`/settings/apps`), especially if an app is marked „featured“.
These _Nextcloud apps_ are installed on the server, expanding the functionality of a base Nextcloud instance.

Here are some Nextcloud apps I've tried, what they do, and a ruling on whether they're worth looking into.
Read „Worth your time?“ as „Adam maybe tried this app and has shared his opinion whether others will find this particular app worth the effort to learn and maintain, based on his own experiences projected onto our possibly different use cases.“
Grain of salt, in other words.
When in doubt, start small (default Nextcloud install), and roll these out thoughtfully if you do at all.

[cols="1,1,2",id=nextcloud-apps-commentary]
.Nextcloud apps commentary
|===
|Nextcloud App |Purpose |Worth your time?

|Antivirus for files |virus scan uploads |*Yes*. Note: https://github.com/nextcloud/files_antivirus/issues/219[uploads from desktop clients are not scanned for viruses].
|Analytics |track and graph metrics |*Yes*. Only for small/simple use cases though.
|Appointments |easy 3rd party scheduling |*Yes*. Requires careful calendar curation. Somewhat fiddly setup.
|Calendar |manage meetings and appointments |*Yes*. See also: <<Spurious event updated notifications>>.
|Circles |arbitrarily group users |*No opinion*. I don't have enough users to justify this.
|Collectives |wiki or knowledge base |*Maybe*. Looks like a useful way to organize a set of related documents. Requires Circles.
|Cookbook |recipe manager |*Yes*. Great at importing from web pages (thanks to standardized recipe data already present in HTML source). I wish it were better at printing/exporting though.
|Contacts |address book |*Yes*.
|Dashboard |landing page |*No*. I like to go right to my files.
|Deck |kanban board |*No opinion*. I tried it a little and it worked, I just don't use kanban much.
|Draw.io |diagram editor |*Yes*.
|Duplicate Finder |find and cull duplicate files |*No*. Slow and opaque. I recommend https://github.com/pauldreik/rdfind[rdfind] instead.
|Electronic Signatures |e-sign documents |*No*. Requires a 3rd party service. I'd rather have drawn signatures. See <<Draw signature in forms>>.
|End-to-End Encryption |encrypt files server-side, decrypt with client |*No*. Unnervingly buggy. Confusing UI/UX. See <<End-to-End Encryption>>.
|Files |file management, sharing |*Yes*, although the „Versions“ tab is not very useful.
|Forms |Google Forms alternative |*Yes*.
|Full text search |search through all documents |*Maybe*. Fast. Buggy. Likely dormant project. See <<Full text search>>.
|Holiday Calendars |easily add public holiday calendars |*Yes*. The configuration for this app shows up under „Personal“ -> „Availability“ for me, not „Groupware“ (although the URL path is `/settings/user/groupware`).
|Maps |maps and directions |*Yes*. Grab a cup of tea if you have lots of photos with GPS coordinate metadata.
|Mail |email |*No opinion*. I tried it briefly and it choked on my bazillion Gmail messages. And yes, I do want to de-Gmail someday.
|Memories |photos |*Yes*. Requires Photos.
|News |track blogs and news via rss/atom feeds |*Yes*.
|Nextcloud Office |edit spreadsheets, slides, etc. |*Yes*. I don't love this but I need it. Maybe that's a „No“? Mobile apps for this are painful. See <<Nextcloud Office>>.
|Notes |simple markdown-based note taking |*Yes*. There's an excellent companion mobile app. Replaced Google Notes for me.
|Passwords |password manager |*No*. Dormant.
|PhoneTrack |location sharing and tracking |*Yes*. UI is feature-rich and complicated. Traveled movement lines are cool.
|Photos |photos, sorta |*No*. Slow, clumsy, lacking features compared with other FOSS photo management software. Use Memories instead. Note that Memories depends on the Photos app.
|Polls |simple polls |*Yes*.
|Ransomware protection |warns for bad file names on upload |*No*. Too many false positives. Unmaintained.
|Recognize |face recognition |*No*.
|Suspicious login |warn about suspicious IPs |*No*. Too many false positives.
|Tasks |tasks/todos |*Yes*.
|Tables |tabular data entry and API |*No*. Not yet, although keep an eye on this as a potentially powerful and useful ((low-code)) platform.
|Talk |video and text chat |*No*. Works, just not as well as other video and text chat services/apps. I do use it for my chicken safety system and I see it improving a lot with each release. For now I recommend https://signal.org[Signal] instead.
|Temporary files lock |avoid edit conflicts |*Yes*.
|Text |edit text documents |*Yes*. I'm a huge fan of Markdown plain text documents, and Nextcloud handles these well. It has a nice web-based collaborative editor. I like pasting in rich text and letting the editor auto-convert it to Markdown. See also: <<Mobile text editing is hard>> and <<Spurious web text editor conflicts>>.
|Video converter |transcode videos |*No*. Cool idea but the project appears dormant.
|===

==== Full text search

(((Nextcloud, full text search and)))
This app allows you to search through all content of all documents on your server.
The search syntax is hard to get right.
It https://github.com/nextcloud/fulltextsearch/issues/601[uses a lot of CPU] and is memory-hungry too.

The GitHub project repositories are pretty quiet. See:

* https://github.com/nextcloud/fulltextsearch/pulse
* https://github.com/nextcloud/files_fulltextsearch/pulse
* https://github.com/nextcloud/fulltextsearch_elasticsearch/pulse

==== Mobile

(((Nextcloud, mobile and)))
Nextcloud works OK as the backend for a mobile device.
It can be your single reliable Quelleof truth for contacts, calendars, tasks, and most everything else that matters on mobile.
You can open files and edit them, but the UI/UX is bad.
See <<Mobile text editing is hard>> for a couple workarounds.

Besides the primary mobile app (called simply „Nextcloud“), there are other mobile apps made to work with Nextcloud apps.
Here are the ones I recommend.
I don't have an iPhone so these are only Android apps.

[cols="1,1,2",id=recommended-nextcloud-mobile-apps]
.Recommended Nextcloud mobile apps
|===
|Mobile app |Works with Nextcloud apps |More info

|DAVx5 |Calendar, Contacts, Tasks |https://davx5.com
|Maps Geofavorites |Maps |https://github.com/penguin86/nextcloud-maps-client
|NC Passwords |Passwords |https://gitlab.com/joleaf/nc-passwords-app
|Nextcloud Cookbook |Cookbook |https://github.com/nextcloud/cookbook
|Notes |Files, Notes, Text |https://github.com/nextcloud/notes-android
|OpenTasks |Tasks |https://github.com/dmfs/opentasks
|Nextcloud Talk |Talk |https://apps.nextcloud.com/apps/spreed
|===

Android devices usually ship with ((groupware)) (calendar and contacts) apps, or you can install your favorite ones.
DAVx5 handles synchronization of groupware data to and from your device.
DAVx5 is only necessary on Android, perhaps because iOS has better native WebDAV support.
DAVx5 is not needed on Murena phones (/e/ OS).

There are actually two Cookbook apps.
Either works fine for me.
I'm not picky, I just need to see the ingredients and directions.
Looks like the one by „Teifun2“ is more popular.

Maps Geofavorites lets you easily save arbitrary GPS coordinates to the Maps Nextcloud app.
Handy for remembering where you parked your bike, for example.

Notes looks best configured in Grid View.

Talk... despite my own advice, I find myself using Talk anyway.
I like having my own chat server, I guess.
I am listing it here because I do actually use it, and to complain that https://github.com/nextcloud/talk-android/issues/217[I can't read messages offline].
It is also under heavy development and improving lots with every release.

These are just a few examples.
Since you've got all your data and Nextcloud always uses open formats, you can ride the wave of improvements and enjoy what works best.
For example, I just started using https://github.com/jonasoreland/runnerup[RunnerUp].
When I save my tracks in Nextcloud, they automatically show up in Maps.
Nice!

==== Nextcloud vs. ownCloud

(((Nextcloud, ownCloud vs.)))
At first glance it's a bit difficult to tell the difference between Nextcloud and ((ownCloud)).
This follows since Nextcloud started as a fork of ownCloud.

So why should you choose one over the other?
A healthy FOSS project is generally also an active project, so one way to guide your decision is by comparing activity metrics on GitHub.
See https://github.com/owncloud/core/pulse[owncloud/core activity] and https://github.com/nextcloud/server/pulse[nextcloud/server activity].
Based on those two sets of metrics it appears Nextcloud is thriving and ownCloud is dying.

Another interpretation is that ownCloud has a smaller and slower-moving core codebase.
More work is necessary to make a truly rigorous comparison.

See also: <<traits-of-good-services>> and <<traits-of-bad-services>> in <<Dienstwahl>>.

==== Nextcloud Office

(((Nextcloud, office and)))
https://nextcloud.com/office/ gives some strong hints how the company behind Nextcloud wants us to think of „office“ and their plans for it as a suite of related tools.
They clearly intend a holistic, integrated office experience, and Nextcloud can be configured to be used in this manner.
https://nextcloud.com/office/ covers editing office documents (rich text and spreadsheets) collaboratively, along with uses for the Notes, Collectives, and Tables apps.
It provides some clever and useful workflow ideas.

Given that wide a scope, ((groupware)) should be part of „office“ too, so instead let's for now focus specifically on collaborative editing of office documents.
Doing this within Nextcloud requires an https://apps.nextcloud.com/apps/richdocuments[app called Nextcloud Office] as well as a separate backend service, either ((Collabora)) or ((ONLYOFFICE)).
My strong preference is for Collabora, in line with <<Geeignet fürs Self-Hosting>>; despite fewer stars on GitHub, it appears Collabora development is flourishing while ONLYOFFICE is stagnant (although it's hard to tell which of the many ONLYOFFICE repositories on GitHub are relevant here).

==== Verschiedene Probleme

Here's a selection of my favorite bugs and feature requests for Nextcloud.

===== Spinner on mobile

When you first open the Nextcloud mobile app, a loading spinner shows up in front of a cached view of whatever files and folders existed the last time you use the app.
If you ignore it and tap to navigate your way into a folder or open a file, you may end up tapping a different one than you intended because the folder order can change _as you are tapping the screen_.

Workarounds:

* wait until the spinner completes (usually takes me about one second)
* reduce chance of reordering with „A - Z“ or „Z - A“ sorting instead of „Newest first“ or „Oldest first“

===== Mobile text editing is hard

(((Nextcloud, mobile and)))
Nextcloud makes it easy to get to your stuff via mobile devices, but editing is a pain.

This is not a Nextcloud-only problem; I find _all_ mobile text entry and editing cumbersome.
This applies to email, plain text, Markdown, and office documents.

In Nextcloud-land, one workaround to improve plain and Markdown text entry is to use the https://github.com/nextcloud/notes-android[Notes app on Android] or https://github.com/nextcloud/notes-ios[iOS].
It has separate editing and viewing modes and more aggressive synchronization.
With Notes you have a better chance of up-to-date data and fewer conflicts.

Another workaround is to use https://github.com/gsantner/markor[Markor].
Install that app, then:

. In the Nextcloud mobile app, „Download“ or „Sync“ the file you wish to view or edit locally.
This caches a copy on your phone.
. In the Nextcloud mobile app, choose „open with“ for the file.
Should open instantly.
. If you make changes to the file, save it, then manually „Sync“ the file in the Nextcloud app.
It appears local changes like these never make it to the server otherwise.

See https://jenson.org/text/ for background on why mobile text editing is a complex and multifaceted problem.

===== Cumbersome mobile setup

To sync calendars, tasks, and contacts with your phone's storage of same on Android, you must install and configure the 3rd party DAVx5 app.
https://help.nextcloud.com/t/what-does-android-file-sync-do-for-a-nextcloud-account/154330[I don't know why DAVx5 is required], but https://murena.com[Murena] figured it out for me.
Their Android-derived /e/ OS includes native support for Nextcloud accounts, removing the requirement for DAVx5.
Users with iOS and other OSes besides Android can sync groupware-related data https://docs.nextcloud.com/server/stable/user_manual/en/groupware/[without DAVx5].

===== Spurious web text editor conflicts

Collaborating on plain text and Markdown text files sometimes results in spurious conflicts.
Editing is interrupted before it starts, and the web-based text file editor shows you two versions of the file side by side.
The left side is labeled „Use current version“, and the right says „Use the saved version“ (or equivalents for your locale or specific client).

Apparently the browser has a saved copy in local storage or something that gets loaded first and considers it the „current“ version.
Then it loads the one on the right and calls it the „saved“ version, and if they differ you get to choose.

Workaround: pick the one on the right.
That's the latest and greatest copy as it exists server-side.

Why the... never mind, just pick the one on the right.
If you're curious and want to dig in deeper, follow these links:

* https://github.com/nextcloud/text/issues/2388[Shared text file is not up-to-date with saved file]
* https://github.com/nextcloud/text/issues/4078[Changing File from Desktop leads to conflict in browser, even if browser was not doing any changes]
* https://help.nextcloud.com/t/text-document-current-vs-saved-version/151600[Text: document current vs. saved version] (by yours truly)

Related desktop client bug: https://github.com/nextcloud/desktop/issues/2467[Nextcloud-Client creating conflicts when it should not].
Conflicts seem to appear in cases where there shouldn't be any.
Workarounds: wait 10 seconds or so between saves until the desktop client syncs and returns to idle (roll your eyes while you wait).
Also, check out the https://apps.nextcloud.com/apps/files_lock[Temporary files lock] app for semi-automated advisory locking (e.g. quickly communicate „gimme a minute, I'm editing that Markdown text file“).

===== Draw signature in forms

Forms are handy for gathering simple minimally-structured data... surveys, RSVPs, stuff like that.
The data are just dumped into a spreadsheet.
With a signature field Forms could be used to add a drawn signature to a form like a contract or waiver.

There are extant Nextcloud online signature apps that incorporate https://en.wikipedia.org/wiki/Digital_signature[digital signatures].
I don't want or need digital signatures, especially since they appear to rely on 3rd party services.
I really just want a low-tech image that looks like a drawn signature at the bottom of a page.
It doesn't even need to be wet ink.
If you want that too, vote for or help with https://github.com/nextcloud/forms/issues/947.

https://github.com/OpenSignLabs/OpenSign[OpenSign] and https://github.com/docusealco/docuseal[DocuSeal] are two alternative FOSS self-hostable apps supporting drawn signatures.

===== Release script missing from source

Nextcloud is FOSS, although https://help.nextcloud.com/t/build-bzip-and-package-from-git/58341[some release scripts are held back].
They may or may not be required to release those, I don't know.
I hope they do decide to release them, for the same reasons the rest of Nextcloud is FOSS.

===== Spurious event updated notifications

The Calendar app is quite useful and perhaps the most heavily used by me and my users.
I have grown to expect one particular erroneous „event updated“ notifications, possibly caused by calendar client/sync issues.

On one shared calendar (with many clients) I often get notifications that so-and-so „updated event XYZ in calendar ABC“, but the only actual thing that occurred is that one of the clients just sync'd (or perhaps made some innocuous change to an event) and https://github.com/nextcloud/calendar/issues/5879[Nextcloud thinks it was a meaningful update].
At least, I think that's what's happening... some changes (like changing the event's date) do show up with the old and new values made explicit.
As an aside, I do like this „explicit diff“ behavior showing the exact changes made to an event's Title, Time, Location, or Description.

==== End-to-End Encryption

End-to-End encrypted folders seems like a great idea.
There's a Nextcloud app for this and I recommend you avoid it.

It seems close to working, but it feels like early-release software.
The UI/UX is confusing, and I ran into a dealbreaker bug that left files decrypted server-side.
Furthermore, https://help.nextcloud.com/t/how-to-setup-e2e-encryption-for-shared-folders/165610[sharing] https://help.nextcloud.com/t/e2ee-and-file-sharing/145547[doesn't] https://github.com/nextcloud/end_to_end_encryption/issues/520[work], https://github.com/nextcloud/end_to_end_encryption/issues/82[there's no web client], https://github.com/nextcloud/end_to_end_encryption/issues/285[the roadmap is unclear], and https://github.com/nextcloud/end_to_end_encryption/issues/8[keys are always stored on the server] (these are thankfully stored encrypted).

ifdef::backend-pdf[]
Sorry for all those really long links.
Whew!
Deep breaths, self, deep breaths.
Count to ten.
endif::[]

Proceed carefully with the End-to-End Encryption Nextcloud app.
Review https://github.com/nextcloud/end_to_end_encryption/issues[known issues], make sure you can live with all those, then test it out thoroughly using a throwaway/sandbox Nextcloud instance.
Make sure it works with all clients you plan to use it with (e.g. desktop, mobile).

==== AIO installer

(((Nextcloud, installing)))
Among the myriad Nextcloud install methods, there's a relatively new and interesting AIO („all-in-one“) installer (https://nextcloud.com/all-in-one).
It's free for an instance with less than 100 users.
The AIO takes a different approach than mario, it configures and manages multiple Nextcloud-related service containers for you.
I recommend the mario method instead for its flexible and empowering experience of learning how to add and manage individual containers yourself.

See the https://github.com/nextcloud/all-in-one[AIO readme] for more information.

== Weitere Ressourcen

Visit https://selfhostbook.com for all supporting material including Quellcode for this book and mario.

* https://selfhostbook.com/code/[Quellcode]
* https://selfhostbook.com/contact/[Contact information]

Patches and feedback are most welcome.
This book is just a part of something big and I'm glad you're a part of it too!

=== Support

Here are a few ideas for when you get stuck.

* Ask for help in forums and chats related to a product/project.
* If you're confident you've found a bug, file an issue with the product/project.
* Ask https://selfhostbook.com/chat/[other readers] for help.
* Try your luck in semi-moderated public places.
Don't expect much from these, although you may get lucky from time to time.
** https://reddit.com/r/selfhosted/[selfhosted subreddit]
** https://reddit.com/r/homelab/[homelab subreddit]
** https://matrix.to/#/#Nextcloud:matrix.org[Nextcloud chat]
** https://matrix.to/#/#selfhosted:matrix.org[self-hosted chat]
* Hire me to help you out.

=== Alternativen zu mario

If you're in a hurry, you can find one-click-install appliances with many ready-to-go apps.
(((FreedomBox)))
https://freedombox.org[FreedomBox] is one promising contender in this space.

There are also many shortcuts and frontends for self-hosting.
For example, https://openmediavault.org[openmediavault] looks like a cool way to build a ((DIY)) (do it yourself) ((NAS)) (network attached storage).

(((YunoHost)))
(((CasaOS)))
(((Runtipi)))
And there are countless more of these kinds of partial or full-service self-hosting solutions, such as:

https://yunohost.org[YunoHost]::
  Not considered, I prefer always using containers.
https://casaos.io[CasaOS]::
  New, interesting, very little documentation.
https://runtipi.io[Runtipi]::
  New, interesting, uses ((Docker Compose)) and Traefik.

These look intriguing, and it's hopeful (and overwhelming) to see many options in this space.
I evaluated these only just enough to get the sense they didn't fit my wants and needs.
I'm a crotchety old man and I'm reluctant to change, but I still do, sometimes.
If and when I adopt something new, it must pass a high bar, ideally most or all these tests:

.Checkliste: Lösungs-Tauglichkeits
[#solution-viability-checklist]
****
* [ ] Will it work for years with minimal tinkering?
* [ ] Is it easily extensible?
* [ ] Do I trust the maintainers?
* [ ] Does it employ technologies I'm familiar with?
* [ ] Does it weaken or strengthen security by changing my ((attack surface))?
* [ ] Does it add features/value I need/want, beyond what I'm already able to do?
* [ ] Will it help my users?
* [ ] Will it help me learn what I need/want to learn, and safely take care of the rest for me without my needing to learn more?
* [ ] Will it help me figure out why I made a change to one of my services two years ago?
* [ ] Does it phone home, using telemetry or my data in a way I don't approve?
* [ ] Does it hold back „enterprise“ features I need, even for my scaled-down use case?
Is it annoying about this, reminding me often?
* [ ] If I want paid support, is it available?
* [ ] Is it popular?
Has it been around a while, and do I expect it to endure?
****

See also: <<traits-of-good-services>> and <<traits-of-bad-services>> in <<Dienstwahl>>.

After brief reviews, I find existing self-hosting solutions generally:

* are new and immature
* lack proper documentation
* do too much: try to solve many problems without sufficient inertia/resources to maintain it all
* don't do enough: just another Linux distro with an added layer to discover and install apps
* make opinionated tech choices I don't agree with
* have a limited list of apps in their app stores and exclude the ones I want
* have too many apps in their app store, without good ways to compare quality, privacy, features
* are GUI (graphical user interface)-focused where I prefer working on a command line

Still, check `'em out.
They might work better for you if you don't need the level of power and control provided by this book.
By the time I publish, they (or some new contenders) might grow to overcome my approach.
Please let me know what you discover.
If I missed something, I'd love to learn about it!

(((Ansible)))
(((Clace)))
(((Cosmos Cloud)))
(((DockSTARTer)))
(((HomelabOS)))
(((Start9)))
(((MicroCloud)))
(((LibreServer)))
(((LinuxServer.io)))
(((NextcloudPi)))
(((UBOS)))
Here are some more related and interesting self-hosting solutions worth researching further:

* https://github.com/davestephens/ansible-nas[Ansible NAS]
* https://clace.io[Clace]
* https://cosmos-cloud.io[Cosmos Cloud]
* https://dockstarter.com[DockSTARTer]
* https://homelabos.com[HomelabOS]
* https://start9.com[Start9]
* https://canonical.com/microcloud[MicroCloud]
* https://libreserver.org[LibreServer]
* https://www.linuxserver.io[LinuxServer.io]
* https://nextcloudpi.com[NextcloudPi]
* https://ubos.net[UBOS]

== Discussion topics

Here are some conversation starters for a class or small group.

. What services do _you_ run?
Why?
For whom?
. What are some considerations when choosing between public cloud and on-premise self-hosting?
. Compare and contrast different options for bloßes Metal self-hosting hardware in terms of setup cost, power usage, and expandability.
. Why does the author encrypt all network traffic, even in a closed LAN?
. Review this book for poor security practices.
How might it be improved?
. Why is privacy important, especially with digital information?
. What's the best part about self-hosting?
. What are some pitfalls of self-hosting?
. What is the future of self-hosting?
. What is the ideal number of users to support with a single self-hosted server?
. Is the _Steadfast_ method useful for larger groups, big families, church congregations, schools, businesses, and governements?
Why or why not?
. How might this book be adapted for:
.. intermittent power
.. intermittent network
.. local-only network
.. clustered hardware
. Consider FOSS with respect to human attention and focus.
Contrast with non-FOSS.
. What approaches in this book may be conceptually dangerous or misleading?
Why?
How could they be improved?
. Summarize this book in one sentence.
. How might you detect if your server has been compromised?

== Übungen

Exercises for individual practice and study groups.

. Stand up a service besides those included with mario using an existing image.
For example, a https://awesome-selfhosted.net/tags/personal-dashboards.html[dashboard].
. Build a custom image.
Hint: use `docker build` or https://buildah.io[Buildah].
. Run a container using your custom image.
. Create a service (using your container) to know if it is time to reboot your server.
Hint: check if `/host/var/run/reboot-required` exists.
. Stand up a second Nextcloud service for experiments.
Use it to test out the latest release or a custom app.
. Try Nextcloud with object storage for primary storage.
. Adapt this guide to a Linux distribution besides Ubuntu.
. Help resolve a bug mentioned in this book.
. Set up periodic automatic offsite backups.
. Add a GPU to your server.
. Enable GPU transcoding in Jellyfin.
. Sign the open letter at https://publiccode.eu[Public Money, Public Code] because software paid for with taxes should be FOSS.
. Aggregate logs.
. Pick a Docker container that doesn't need to be able to initiate outbound network connections.
Prevent it from doing so and prove to yourself it works.
. What if the server won't boot?
.. Describe troubleshooting steps, in detail.
.. Make a plan for system recovery when it fails to boot.
. Set up https://en.wikipedia.org/wiki/Single_sign-on[single sign-on].
. Set up https://fail2ban.org[Fail2Ban].
Feed it logs from various services.
. Set up https://suricata.io[Suricata] network analysis and threat detection.
. Try running containers with https://podman.io[podman].
. Read up on other ways to isolate processes, e.g. FreeBSD jails and chroot.
. Contribute to mario.
. Move secrets used by mario into an Ansible vault or a self-hosted service intended for managing secrets.
. Adapt mario to use podman.
. Adapt mario to use https://kubernetes.io[Kubernetes].
. If you have a dynamic WAN IP address, create or use an existing dynamic DNS update client container.
. Stand up a mail relay container such as https://github.com/crazy-max/docker-msmtpd or https://github.com/namshi/docker-smtp.
Allow all mario-managed services to send email through this relay.
. Stand up your own DNS server.
. Reorganize mario services into distinct Ansible roles.
Upload the roles to https://galaxy.ansible.com[Ansible Galaxy] as a playbook bundle.
. Traefik's Docker integration has https://doc.traefik.io/traefik/providers/docker/#docker-api-access[security implications].
Test these risks against your security considerations following <<Bedrohungsmodell>>.
If you should mitigate this risk based on your threat model, harden mario so even if Traefik were compromised it would not compromise the whole server.
Review the Traefik docs on this topic and https://github.com/wollomatic/traefik-hardened[traefik-hardened] to get some ideas.
. Modify mario to https://docs.docker.com/engine/security/userns-remap/[always run containers as unprivileged (non-root) users].
. Use appropriate ownership and permissions for persistent container data.
. Set up https://github.com/strukturag/nextcloud-spreed-signaling#running-with-docker[Nextcloud Talk high-performance backend].
. https://docs.docker.com/network/packet-filtering-firewalls/#docker-and-ufw[Uncomplicated Firewall and Docker do not get along well].
Work around this and share your solution with others.
. Try https://nixos.org[Nix and NixOS].
. Roll your own Linux distro.
. Build, configure and deploy an https://opnsense.org[OPNsense firewall].
. Set up your own https://headscale.net[headscale] VPN/tailnet for remote LAN access.
. Improve preview/thumbnail generation in Nextcloud.
.. Research first: Will you and your users benefit from the change?
Are there security implications?
How does default preview generation work?
What file types are supported by the default previewer and other previewers?
How much disk space is used?
How fast is it, subjectively and objectively?
What maintenance will it require once enabled?
.. Create a test bed with a clean install and many preview-able files of various file formats.
Find or write code for recording objective performance metrics (e.g. time it takes to generate previews for a folder containing many files of various types).
Consider both client- and server-side performance.
Keep manual testing notes (subjective measurements).
.. Compare https://apps.nextcloud.com/apps/previewgenerator[Preview Generator], https://github.com/h2non/imaginary[Imaginary], and any other extant previewers.
.. Establish baseline performance metrics before making any changes.
.. Enable one or the other, get timings, repeat for each previewer.
.. Evaluate the change.
Is it noticeable?
Does your timing script show any difference?
How much disk space is used for previews?
How challenging was this to enable?

The detailed steps in the last exercise suggest what may be required in general to achieve better outcomes.
I've omitted them from the other exercises for brevity.
Please apply similar detailed steps elsewhere as desired.

:sectnums!:

== Afterword

In the words of Scott McNealy, former CEO of Sun Microsystems:

____
Open Quelleis free like a puppy is free.
____

Everybody loves a puppy, right?
_Right??_
I sure hope so.
Because--fair warning--if you spend too much time with your „puppy“ (self-hosting, FOSS, etc.), your partner will show up with an actual puppy.

[#image-puppy]
.Open Quelleis free like a puppy. Pictured: actual puppy.
image::puppy.jpg[align="center",scaledwidth=80%]

If your problem is _that_ cute, I suppose it's not too a bad problem to have.
I hope you find what you need to keep _your_ puppies happy!

Finally, I'd like to share an Ursula K. Le Guin quote.
According to her:

____
A book is just a box of words until a reader opens it.
____

Dear Reader, _this book exists because you exist_.
I hope it serves you well.
I am humbled and grateful for your support.
Thank you, thank you, thank you.

== Danksagungen

Sometimes I feel more like a birthday boy than an author, accepting gifts from so many generous people.
I truly couldn't have done this alone and I am so, so grateful for you.

Thanks to Eva for more than I could ever account for here, from „What if it rains?“ to leading by learning and fearlessly doing.
For supporting my dreams, including this book: your several inspiring rounds of thoughtful code review, technical critique, developmental editing, copy editing, proof reading, and line editing.

Thanks to my daughter for your fantastic illustrations.

Thanks to Deb Nicholson for writing the meaningful Foreword.

Thanks to my family and friends for tolerating my protracted FOSS self-hosting boondoggles, including this book.

Thanks to _Pro Git 2_, my inspiration to switch to Asciidoctor.

Thanks to the contributors to the myriad FOSS programs I used to create this book, especially John MacFarlane and the Pandoc team, Dan Allen and the Asciidoctor team, and Bram Moolenaar and the Vim team (rest in peace, Bram).

Thanks to Rob Smith and all #underlug for help with hardware, networking, Ansible, and Traefik.

Thanks to the „Deadbeat Dads“ Bryan Daisley and Rob Floberg for your invaluable feedback.

// alphabetical by last name

Thanks to all my beloved beta testers, including Andrew Davidson, Brendan Kidwell, Eva Monsen, Don O'Neill, and Lenny Wondra.

Thanks to Bob Nystrom for your mind-expanding design review.

Thanks to Lenny Wondra for your deeply effective tech review and editing.

Thanks most of all to my wife and kids for supporting and believing in me.
For all the cooking, talking, listening, art, coding, math, music, and love.
Aren't we lucky?!

== Glossary

Here's a list of definitions for some of the more non-obvious terms I use in this book to clarify how I use them.
These stick to common use as much as possible.
Specialists in computer science, security, administration, networking and so on will have more nuanced definitions.

// Quellefor "These days that pretty much means git" statement: https://en.wikipedia.org/wiki/Git#Adoption

((AI))::
  Artificial intelligence.
((API))::
  Application programming interface. Provides a way to interact with a service from software. Useful for writing apps and integrations.
((attack surface))::
  Total of possible attack vectors. Fewer is more secure. Example: closing all but the ports you need open reduces yours.
((backend))::
  I use this term to refer to either a service (e.g. a database) or server. It's something you more frequently interact with indirectly, say, via a frontend like a web app or mobile UI.
((bloßes Metal))::
  Physical nearby computing resources, as opposed to rented compute time on someone else's hardware. Used in this book primarily to indicate hardware autonomy.
((block storage))::
  Cloud storage option with direct filesystem access including files and folders. Used directly/natively/locally from an OS. Size is relatively fixed and determined at creation time.
((bot))::
  Short for robot. Software performing autonomous tasks such as responding to chat requests or attacking vulnerable servers.
((cattle vs. pets))::
  Highlights two distinct sysadmin approaches to systems/services. Cattle are automated, ephemeral, and hopefully immutable. Pets are managed manually, stateful, and long-lived.
((cert))::
  Shorthand for HTTPS encryption certificate.
((change management))::
  The means and methods of transitioning a group of people from one set of tools and processes to another.
((cloud))::
  An ambiguous amount of remote hardware. Scalable, programmable, and networked. „The cloud“ or „public cloud“ is someone else's hardware while „personal cloud“ is your own.
((cluster))::
  Collated collection of machines treated as a single machine to achieve higher scale computing power.
((compute))::
  Noun: CPU or GPU resources expended when running software services.
((container))::
  Running instance of an image. Containers may also be referred to as „guests“, although this is more commonly used to describe VMs.
((CPU))::
  Central processing unit. The main brain of the computer; the place where most of the math happens.
((data))::
  Noun, plural. Yes, I use the annoying plural form! Sorry, old habit.
((data sovereignty))::
  Full control of your data. For example, having original copies of your files.
((deploy))::
  Prepare a service for use. Typically involves building or copying files before a service is started.
((dogfooding))::
  Being a user of something you also created and/or maintain. „Eat your own dogfood.“
((DHCP))::
  Dynamic Host Configuration Protocol. This is one way computers get IP addresses and related networking settings.
((DIY))::
  Do it yourself. Said of activities involving some amount of learning and tinkering you'd otherwise pay for. Cooking, for example. Also: self-hosting.
((DNS))::
  Domain Name System. Maps domain names to IP addresses.
((domain name))::
  How a server, service, or group of services are identified, e.g. `example.com`.
((DRM))::
  Digital restrictions management. Ancient, evil technology designed to prevent unapproved consumption of content. Probably used for surveillance too.
((egress))::
  Any outbound data transfer or download, in public cloud terms.
((entrypoint))::
  How traffic enters the Traefik Reverse-Proxy; network ports.
((firewall))::
  Means of controlling network traffic between computers.
((fork))::
  Verb: to split one software project into two. Noun: a derivative software work. The fork diverges from the original (otherwise it would simply be a copy). One or many software projects may succeed the original. Forking software is a useful and common activity.
((FOSS))::
  Free and open-Quellesoftware. An acronym designed to unite the goals of the FSF and the OSI.
((FSF))::
  Free Software Foundation. They strongly defend the „F“ in FOSS.
((frontend))::
  The UI for a system or service.
((full-disk encryption))::
  When an entire storage area is cryptographically protected.
((GB))::
  Gigabyte. Typically 1,000^3^ (1,000,000,000) bytes for HDDs, or 1,024^3^ (1,073,741,824) bytes for RAM, for historical reasons. Cloud storage providers use the second (powers of two) form.
((good, fast, and cheap))::
  Used with a wink in this text because https://en.wikipedia.org/wiki/Project_management_triangle[typically we must pick two].
((Good Thing))::
  A hand-wavy way of saying something is self-evidently wonderful.
((groupware))::
  Software for group collaboration. Loosely: mail, calendar, and contacts. Sometimes includes collborative editing of office documents and spreadsheets.
((GPU))::
  Graphics processing unit. Originally intended for graphics. Found to be useful for many specialized compute workloads including transcoding video.
((GUI))::
  Graphical user interface.
((HDD))::
  Hard disk drive. Stores ones and zeros on spinning metal platters.
((homelab))::
  A physical or conceptional space for do-it-yourself flexible systems administration leaning and experimentation. A homelab is not quite what this book describes, it is more of an at-home hardware, software, and electronics maker-space. A _Steadfast_ server (or „personal cloud“) should be nearly always online and useful--at least the user-facing part. Some self-hosters call this environment „homeprod“. Far from this level of hair-splitting detail, I'll use „homelab“ as a shortcut for „self-hosting setup“ and/or „homeprod“.
((host))::
  The computer where Docker containers run. Also called a „server“ in this text.
((hostname))::
  Name for a single server/computer/device.
((HVAC))::
  Heating, ventilation, and air conditioning.
((idempotent))::
  An operation which enacts changes only until an end state is reached. Repeating the operation has no effect once the end state is reached. For example, updating an OS. After the OS is up to date, updating again will cause no changes to the list of installed packages (assuming no new updates become available while updating).
((image))::
  A filesystem with code and dependencies necessary to run a container.
((immutable))::
  Doesn't change. For example, a particular Docker image. A container instantiated from that image can be modified, but the image cannot; a new image must be built.
((IPMI))::
  Intelligent Platform Management Interface. Used for remote server management including reboots and OS installs.
((IPS))::
  Intrusion prevention system. Mitigates the risk of penetration.
((isolation))::
  For software services: Keep separate from others. Eases sysadmin tasks such as preventing dependency version conflicts.
((ISP))::
  Internet service provider.
((kernel))::
  The part of the OS that talks directly with hardware.
((LAN))::
  Local area network. For example, the network used by computers and devices to talk with each other inside your home.
((LFNW))::
  LinuxFest Northwest. Annual conference in Bellingham, Washington dedicated to serving and connecting open Quellecommunities. Established in 2000.
((Linux))::
  The most popular server OS. Also works fine on a desktop or laptop. The old me would have insisted on calling it „GNU/Linux“ or „a Linux distribution“. A lot has happened since then, and I've come to believe „Linux“ is enough to describe the OS used for self-hosting in the context of this book.
((low-code))::
  High-level application development platform with reduced focus on traditional programming. Typically provides a GUI and requires less files with configuration and code. Useful for prototyping or replacing some simpler data entry and analysis applications.
((LTS))::
  Long-term support. A stable software release, supported for many years.
((mario))::
  Provisioning system included with this book to assist with learning how to set up and maintain your own server. Consists of scripts, documentation, and configuration files.
((NAS))::
  Network-attached storage. A server made for storing data. Usually has several HDD bays in a non-rackmount box-like form factor. Likely has less CPU and RAM (and less power usage) than what I describe in <<Server>>.
((NIC))::
  Network interface card, also called a network adapter. Hardware for receiving and sending data over a network.
((object storage))::
  Relatively unlimited and typically remote cloud storage option. Actual data are abstracted: backups and structured access require special services, indexes, and software.
((OCR))::
  Optical character recognition. The process of converting images of text to actual text.
((OOB))::
  Out-of-band (management). A means of remote low-level server control including power cycling and console interaction, typically provided by an independently powered and networked embedded computer. See also: IPMI.
(((operating system)))
OS::
  Operating system.
((OSI))::
  Open QuelleInitiative. More concerned with the „OSS“ of FOSS.
((PHP))::
  PHP: Hypertext Processor. Programming language built for the web.
((PoE))::
  Power over ethernet. Utilizes an ethernet cable for electricity as well as data.
((port))::
  Along with an IP address, a number used to connect to a service. Reserved port numbers such as 80 for HTTP are listed in `/etc/services`.
((partition))::
  Delineated section of a HDD or block storage, formatted with a filesystem such as ext4 or ZFS.
((port forward))::
  Router configuration to send traffic for a particular port to a computer inside a LAN.
((process))::
  Instance of running software. Note that „running“ processes are described in more detail by a lower-level state such as running, sleeping, idle, waiting for I/O completion and--my personal favorite--zombie.
((provision))::
  As in, „provision a server“. Set up a machine or otherwise bring it into alignment with a known/good configuration.
((RAID))::
  Redundant array of inexpensive disks. Allows flexible use of multiple drives for redundancy and/or speed, as desired.
((registrar))::
  Domain name vendor. May also offer other name- and hosting-related services.
((reproducible))::
  Able to be repeated following specific steps. E.g. „repro“ a bug or „a reproducible [software] build“. If two people try to repro a bug, they should have the same experience. If two people each build an image from the same `Dockerfile`, they should produce the same image. In practice, bug repros and build products are close enough and never exactly the same.
((Reverse-Proxy))::
  Networking software for filtering and directing traffic. In a self-hosted context, useful for SSL termination and for running several self-hosted web services with different domain names with a single IP address.
((router))::
  Network device used to handle traffic at the boundary between networks such as a WAN and LAN. A SOHO router typically also provides various other functions including DNS, DHCP, switching, firewalling, and Wi-Fi. See: port forward. A Traefik router is something different: this is a software logic connecting entrypoints to services. See <<Traefik Architektur>>.
((runtime))::
  The period of time when a software is running; when a set of machine instructions becomes a running process. Also used to describe a set of tools/libraries to facilitate same. May appear as „runtime environment“ in the latter form.
((SeaGL))::
  Seattle GNU/Linux Conference. Held yearly since 2013.
((server))::
  A computer that generally stays powered on and uses networking for interaction instead of a monitor, keyboard, or mouse. Also called a „host“.
((service))::
  A long-running process used by other local and remote processes to do something useful.
((SOHO))::
  Small office / home office.
((Quellecontrol))::
  A system for tracking changes in Quellcode along with who made the change, why, and when. Git is one such system.
((Quelleof truth))::
  The authoritative (home for a) document, perhaps among some number of available choices/copies.
((SSD))::
  Solid-state drive. A hard drive that doesn't spin.
((SSH))::
  Secure Shell. Provides encrypted remote command line access to a server.
((SSL termination))::
  Accepting encrypted traffic and passing along unencrypted traffic. Act performed by Traefik Reverse-Proxy in a mario-provisioned server. More accurately and less often referred to as „TLS termination“. Actual SSL is deprecated.
((sysadmin))::
  Portmanteau of „systems administrator“. A party responsible for the upkeep of a computer system.
((threat model))::
  Analysis of risks and defenses of digital assets.
((TB))::
  Terabyte. Like GB, can be either base-10 or base-2, so: 1,000^4^ (1,000,000,000,000) bytes for HDDs and 1,024^4^ (1,099,511,627,776) bytes for RAM.
((TLD))::
  Top-level domain. For „example.com“, „.com“ is the TLD.
((UI))::
  User interface. The means of interaction between a user and a system, e.g.: a web site or mobile app. Often considered along with user experience and notated „UI/UX“.
((UPS))::
  Uninterruptible power supply. A battery that sits between your server and an outlet, often with extra features such as a power outage alarm or surge suppressor.
((UX))::
  User experience. The nature of interaction between a user and a system they are using. Includes ease of use and steps involved to complete a task. Often considered along with user interface and written as „UI/UX“.
((volume))::
  Docker facility to mount a folder on the server to a folder inside a container. This is a common means of persisting container data that would otherwise be ephemeral.
((VM))::
  Virtual machine. OS isolation technique simulating nearly all aspects of hardware including power, input, and output.
((VPN))::
  Virtual private network. Useful to „teleport home“ and behave (from a networking perspective) as if you are inside your home LAN.
((WAN))::
  Wide-area network. Everything outside your LAN / home network / router.
((ZFS))::
  A filesystem with many advanced features such as encryption, bit rot mitigation, journaling, volume management, and snapshotting. Used to stand for Zettabyte File System.

// Ideally I'd like a full set of these lists for every output.
// See am64 in ../Readme.adoc
//
// The ifndef block disables all cross references for print PDF output. See:
// * https://github.com/Alwinator/asciidoctor-lists/issues/14
// * https://discuss.asciidoctor.org/asciidoctor-pdf-cross-ref-to-a-page-number-td8418.html
//
// An EPUB backend quirk necessitates explicit IDs for everything. See:
// * https://github.com/Alwinator/asciidoctor-lists/issues/25

ifndef::shb-printPdf[]
== Cross references

Here are lists of links to significant blocks of titled content.

=== Figures

list-of::image[]

=== Tables

list-of::table[]

=== Sidebars

list-of::sidebar[]

=== Code snippets

list-of::listing[]

endif::[]

// only matters for PDF output
// see https://docs.asciidoctor.org/asciidoc/latest/sections/user-index/
ifdef::backend-pdf[]
[index]
== Index
endif::[]
